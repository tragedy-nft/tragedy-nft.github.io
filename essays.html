<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Essay Collection - The Mythical Cursed-Nightmare</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="alternate icon" href="favicon.svg" />

    <!-- Apple Touch Icon (180x180 for iOS) -->
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.svg" />

    <!-- PWA対応 -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <!-- Additional Meta Tags -->
    <meta name="theme-color" content="#6B46C1" />
    <meta
      name="description"
      content="Essay Collection - Legendary Tales from the Cursed Realm. Explore the complete anthology of generated essays."
    />

    <link rel="stylesheet" href="css/styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
      .stories-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 20px;
        margin-top: 30px;
      }

      .story-card {
        background: rgba(107, 70, 193, 0.1);
        border: 1px solid rgba(107, 70, 193, 0.3);
        border-radius: 15px;
        padding: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .story-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 30px rgba(147, 51, 234, 0.4);
        border-color: #a78bfa;
      }

      .story-card.legendary {
        border-color: #ef4444;
      }

      .story-card.epic {
        border-color: #a78bfa;
      }

      .story-card.rare {
        border-color: #60a5fa;
      }

      .story-card.trinity {
        border-color: #4ade80;
      }

      .story-card.ultimate {
        border-color: #fbbf24;
      }

      .story-thumbnail {
        width: 100%;
        height: 150px;
        border-radius: 10px;
        object-fit: cover;
        margin-bottom: 15px;
      }

      div.story-thumbnail {
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      div.story-thumbnail svg {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .story-title {
        font-size: 1.3em;
        color: #e9d5ff;
        margin-bottom: 10px;
        font-weight: bold;
      }

      .story-excerpt {
        font-size: 0.9em;
        color: #c084fc;
        line-height: 1.4;
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .story-meta {
        margin-top: 15px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.8em;
        color: #9ca3af;
      }

      .story-id {
        background: rgba(0, 0, 0, 0.3);
        padding: 4px 10px;
        border-radius: 15px;
      }

      .filter-controls {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin: 20px 0;
        flex-wrap: wrap;
      }

      .filter-button {
        background: rgba(107, 70, 193, 0.2);
        border: 1px solid rgba(107, 70, 193, 0.3);
        padding: 8px 20px;
        border-radius: 20px;
        color: #c084fc;
        cursor: pointer;
        transition: all 0.3s;
        font-size: 14px;
      }

      .filter-button:hover {
        background: rgba(107, 70, 193, 0.3);
        color: #e9d5ff;
      }

      .filter-button.active {
        background: linear-gradient(45deg, #6b46c1, #9333ea);
        color: white;
        border-color: transparent;
      }

      .load-more {
        text-align: center;
        margin: 40px 0;
      }

      .story-badge {
        position: absolute;
        top: 10px;
        right: 10px;
        background: linear-gradient(45deg, #ffd700, #ffa500);
        color: #1a0033;
        padding: 4px 10px;
        border-radius: 15px;
        font-size: 0.7em;
        font-weight: bold;
      }

      .story-badge.legendary {
        background: linear-gradient(45deg, #dc2626, #ef4444);
        color: white;
      }

      @media (max-width: 768px) {
        .stories-grid {
          grid-template-columns: 1fr;
          gap: 15px;
        }

        .story-card {
          padding: 15px;
        }

        .story-thumbnail {
          height: 120px;
        }

        .story-title {
          font-size: 1.1em;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Essay Collection</h1>
      <p style="font-size: 20px; color: #ddd; margin-top: 8px; text-align: center; font-weight: 500">
        Legendary Tales from the Cursed Realm
      </p>
      <p style="font-size: 14px; color: #666; margin-top: 15px; text-align: center">
        Explore the complete anthology of generated essays
      </p>

      <div class="button-group">
        <button onclick="window.location.href='index.html'">← Back to Home</button>
        <button onclick="window.location.href='story.html'">Chronicles</button>
        <button onclick="window.location.href='manifesto.html'">Manifesto</button>
      </div>

      <div class="filter-controls">
        <button class="filter-button active" onclick="filterStories('all')">All</button>
        <button class="filter-button" onclick="filterStories('rare')">Rare</button>
        <button class="filter-button" onclick="filterStories('epic')">Epic</button>
        <button class="filter-button" onclick="filterStories('trinity')">Trinity</button>
        <button class="filter-button" onclick="filterStories('ultimate')">Ultimate</button>
        <button class="filter-button" onclick="filterStories('legendary')">Legendary</button>
      </div>

      <div id="storiesGrid" class="stories-grid">
        <!-- Stories will be dynamically loaded here -->
      </div>

      <div class="load-more">
        <button onclick="loadMoreStories()" class="nav-button">Load More Essays</button>
      </div>

      <footer style="text-align: center; margin-top: 40px; padding-top: 20px; color: #c084fc; font-size: 14px">
        © 2025 The Mythical Cursed-Nightmare
      </footer>
    </div>

    <script>
      // Cache configuration
      const CACHE_KEY = 'mythOfTragedy_essays';
      const CACHE_VERSION = '1.0';
      const CACHE_EXPIRY_HOURS = 24;
      
      const LEGENDARY_CACHE_KEY = 'mythOfTragedy_legendary';
      const LEGENDARY_CACHE_VERSION = '1.0';
      const LEGENDARY_CACHE_EXPIRY_DAYS = 14; // 2 weeks

      let allStories = [];
      let currentFilter = 'all';
      let displayCount = 12;
      let filteredStories = [];
      let provider = null;
      let contracts = {};
      let isLoading = false;
      let legendaryTokenIds = [];

      // Cache management
      function getCachedData() {
        try {
          const cached = localStorage.getItem(CACHE_KEY);
          if (!cached) return null;
          
          const data = JSON.parse(cached);
          const now = new Date().getTime();
          const expiry = CACHE_EXPIRY_HOURS * 60 * 60 * 1000;
          
          if (data.version !== CACHE_VERSION || now - data.timestamp > expiry) {
            localStorage.removeItem(CACHE_KEY);
            return null;
          }
          
          return data.stories;
        } catch (error) {
          console.error('Cache read error:', error);
          return null;
        }
      }

      function setCachedData(stories) {
        try {
          const data = {
            version: CACHE_VERSION,
            timestamp: new Date().getTime(),
            stories: stories
          };
          localStorage.setItem(CACHE_KEY, JSON.stringify(data));
        } catch (error) {
          console.error('Cache write error:', error);
        }
      }

      // Initialize provider and contracts
      async function initializeContracts() {
        try {
          // Load configurations
          const [blockchainResponse, deploymentResponse] = await Promise.all([
            fetch('/config/blockchain.json'),
            fetch('/config/deployment.json')
          ]);
          
          if (!blockchainResponse.ok || !deploymentResponse.ok) {
            throw new Error('Failed to load configurations');
          }
          
          const blockchainConfig = await blockchainResponse.json();
          const deployment = await deploymentResponse.json();
          
          const defaultNetwork = blockchainConfig.defaultNetwork;
          const networkConfig = blockchainConfig.networks[defaultNetwork];
          
          provider = new ethers.providers.JsonRpcProvider(networkConfig.rpcUrl);
          
          // Only initialize contracts we need
          const bankedNFTAbi = [
            'function totalSupply() view returns (uint256)',
            'function tokenByIndex(uint256 index) view returns (uint256)'
          ];
          
          const metadataBankAbi = [
            'function getMetadata(uint256 index) view returns (string)'
          ];
          
          const legendaryBankAbi = [
            'function getLegendaryCount() view returns (uint256)',
            'function legendaryIds(uint256 index) view returns (uint256)'
          ];
          
          contracts.bankedNFT = new ethers.Contract(
            deployment.contracts.BankedNFT,
            bankedNFTAbi,
            provider
          );
          
          contracts.metadataBank = new ethers.Contract(
            deployment.contracts.MetadataBank,
            metadataBankAbi,
            provider
          );
          
          contracts.legendaryBank = new ethers.Contract(
            deployment.contracts.LegendaryBank,
            legendaryBankAbi,
            provider
          );
          
          return true;
        } catch (error) {
          console.error('Failed to initialize contracts:', error);
          return false;
        }
      }

      // Fetch metadata from contract
      async function fetchMetadataFromContract(tokenId) {
        try {
          const index = Number(tokenId) - 1;
          let metadataUri = await contracts.metadataBank.getMetadata(index);

          // Handle proxy pattern
          if (metadataUri.startsWith('0x') && metadataUri.length === 42) {
            const metadataBankAbi = [
              'function getMetadata(uint256 index) view returns (string)'
            ];
            const proxyMetadataBank = new ethers.Contract(metadataUri, metadataBankAbi, provider);
            metadataUri = await proxyMetadataBank.getMetadata(index);
          }

          // Decode metadata
          let metadata;
          if (metadataUri.startsWith('data:application/json;base64,')) {
            const base64Json = metadataUri.replace('data:application/json;base64,', '');
            const jsonString = atob(base64Json);
            metadata = JSON.parse(jsonString);
          } else if (metadataUri.startsWith('{')) {
            metadata = JSON.parse(metadataUri);
          } else {
            throw new Error('Invalid metadata format');
          }

          // Extract story data
          const rarity = metadata.attributes?.find(a => a.trait_type === 'Rarity')?.value?.toLowerCase() || 'common';
          const isLegendary = metadata.attributes?.find(a => a.trait_type === 'Legendary') !== undefined;
          
          return {
            id: tokenId,
            title: metadata.name.replace(/#\d+$/, '').trim(),
            excerpt: metadata.description,
            rarity: rarity,
            image: metadata.image,
            isLegendary: isLegendary,
            attributes: metadata.attributes
          };
        } catch (error) {
          console.error(`Failed to fetch metadata for token ${tokenId}:`, error);
          return null;
        }
      }

      // Load all minted NFTs
      async function loadAllStories() {
        const storiesGrid = document.getElementById('storiesGrid');
        
        // Check cache first
        const cachedStories = getCachedData();
        if (cachedStories && cachedStories.length > 0) {
          allStories = cachedStories;
          filteredStories = [...allStories];
          displayStories();
          
          // Update cache in background
          updateCacheInBackground();
          return;
        }

        // No cache, load from contract
        storiesGrid.innerHTML = '<p style="text-align: center; color: #C084FC;">Loading essays from blockchain...</p>';
        
        if (!await initializeContracts()) {
          storiesGrid.innerHTML = '<p style="text-align: center; color: #EF4444;">Failed to connect to blockchain. Please refresh the page.</p>';
          return;
        }

        try {
          const totalSupply = await contracts.bankedNFT.totalSupply();
          const total = totalSupply.toNumber();
          
          if (total === 0) {
            storiesGrid.innerHTML = '<p style="text-align: center; color: #C084FC;">No NFTs have been minted yet.</p>';
            return;
          }

          // Load in batches for better performance
          const batchSize = 10;
          const stories = [];
          
          for (let i = total; i >= 1; i -= batchSize) {
            const batch = [];
            const start = Math.max(1, i - batchSize + 1);
            
            for (let j = i; j >= start; j--) {
              batch.push(fetchMetadataFromContract(j));
            }
            
            const results = await Promise.all(batch);
            stories.push(...results.filter(s => s !== null));
            
            // Update display progressively
            if (stories.length > 0) {
              allStories = stories;
              filteredStories = [...allStories];
              displayStories();
            }
          }

          // Cache the loaded data
          setCachedData(stories);
          
        } catch (error) {
          console.error('Failed to load stories:', error);
          storiesGrid.innerHTML = '<p style="text-align: center; color: #EF4444;">Failed to load essays. Please try again.</p>';
        }
      }

      // Update cache in background
      async function updateCacheInBackground() {
        if (!contracts.bankedNFT) {
          if (!await initializeContracts()) return;
        }

        try {
          const totalSupply = await contracts.bankedNFT.totalSupply();
          const total = totalSupply.toNumber();
          
          // Check if there are new NFTs
          const highestCachedId = Math.max(...allStories.map(s => s.id), 0);
          if (total <= highestCachedId) return;

          // Load only new NFTs
          const newStories = [];
          for (let i = total; i > highestCachedId; i--) {
            const story = await fetchMetadataFromContract(i);
            if (story) newStories.push(story);
          }

          if (newStories.length > 0) {
            // Prepend new stories and update cache
            allStories = [...newStories, ...allStories];
            filteredStories = [...allStories];
            setCachedData(allStories);
            
            // Re-display if on 'all' filter
            if (currentFilter === 'all') {
              displayStories();
            }
          }
        } catch (error) {
          console.error('Background cache update failed:', error);
        }
      }

      function createStoryCard(story) {
        const card = document.createElement('div');
        card.className = `story-card ${story.rarity}`;

        let badgeHtml = '';
        // Show legendary badge for all legendary NFTs (minted or not from LegendaryBank)
        if (story.isLegendary || story.rarity === 'legendary') {
          badgeHtml = '<div class="story-badge legendary">⚡ LEGENDARY</div>';
        }

        let imageHtml = '';
        if (story.image && story.image.startsWith('data:image/svg+xml;base64,')) {
          try {
            const base64Svg = story.image.replace('data:image/svg+xml;base64,', '');
            let svg = atob(base64Svg);
            
            // Make filter IDs unique by adding story ID
            svg = svg.replace(/id="colorFilter"/g, `id="colorFilter-${story.id}"`);
            svg = svg.replace(/filter="url\(#colorFilter\)"/g, `filter="url(#colorFilter-${story.id})"`);
            
            imageHtml = `<div class="story-thumbnail">${svg}</div>`;
          } catch (e) {
            imageHtml = `<img src="${story.image}" alt="${story.title}" class="story-thumbnail">`;
          }
        } else if (story.image === '/assets/monsters/question.svg') {
          // Special handling for question.svg to match size
          imageHtml = `<img src="${story.image}" alt="${story.title}" class="story-thumbnail" style="object-fit: contain; padding: 20px;">`;
        } else {
          imageHtml = `<img src="${story.image}" alt="${story.title}" class="story-thumbnail">`;
        }

        card.innerHTML = `
          ${badgeHtml}
          ${imageHtml}
          <div class="story-title">#${story.id} ${story.title}</div>
          <div class="story-excerpt">${story.excerpt}</div>
          <div class="story-meta">
            <span class="story-id">ID: ${story.id}</span>
            <span>${story.rarity.charAt(0).toUpperCase() + story.rarity.slice(1)}</span>
          </div>
        `;

        // Only add click handler for minted NFTs or non-legendary
        if (story.image !== '/assets/monsters/question.svg') {
          card.onclick = () => {
            window.location.href = `generate.html?id=${story.id}`;
          };
        } else {
          // Add visual feedback that it's not clickable
          card.style.cursor = 'not-allowed';
          card.style.opacity = '0.8';
        }

        return card;
      }

      function displayStories() {
        const storiesGrid = document.getElementById('storiesGrid');
        storiesGrid.innerHTML = '';

        const storiesToShow = filteredStories.slice(0, displayCount);

        if (storiesToShow.length === 0) {
          storiesGrid.innerHTML = '<p style="text-align: center; color: #C084FC; grid-column: 1/-1;">No essays found for this filter.</p>';
          return;
        }

        storiesToShow.forEach(story => {
          const card = createStoryCard(story);
          storiesGrid.appendChild(card);
        });
      }

      async function filterStories(filter) {
        currentFilter = filter;
        displayCount = 12;

        // Update active button
        document.querySelectorAll('.filter-button').forEach(btn => {
          btn.classList.remove('active');
        });
        event.target.classList.add('active');

        // Handle legendary filter
        if (filter === 'legendary') {
          await loadLegendaryStories();
          return;
        }

        // Filter stories
        if (filter === 'all') {
          filteredStories = [...allStories];
        } else {
          filteredStories = allStories.filter(story => story.rarity === filter);
        }

        displayStories();
      }

      // Get cached legendary IDs
      function getCachedLegendaryIds() {
        try {
          const cached = localStorage.getItem(LEGENDARY_CACHE_KEY);
          if (!cached) return null;
          
          const data = JSON.parse(cached);
          const now = new Date().getTime();
          const expiry = LEGENDARY_CACHE_EXPIRY_DAYS * 24 * 60 * 60 * 1000;
          
          if (data.version !== LEGENDARY_CACHE_VERSION || now - data.timestamp > expiry) {
            localStorage.removeItem(LEGENDARY_CACHE_KEY);
            return null;
          }
          
          return data.tokenIds;
        } catch (error) {
          console.error('Legendary cache read error:', error);
          return null;
        }
      }

      function setCachedLegendaryIds(tokenIds) {
        try {
          const data = {
            version: LEGENDARY_CACHE_VERSION,
            timestamp: new Date().getTime(),
            tokenIds: tokenIds
          };
          localStorage.setItem(LEGENDARY_CACHE_KEY, JSON.stringify(data));
        } catch (error) {
          console.error('Legendary cache write error:', error);
        }
      }

      // Load legendary stories from LegendaryBank
      async function loadLegendaryStories() {
        const storiesGrid = document.getElementById('storiesGrid');
        
        // Check cache first
        const cachedIds = getCachedLegendaryIds();
        if (cachedIds && cachedIds.length > 0) {
          console.log(`[${new Date().toISOString()}] Using cached legendary IDs: ${cachedIds.length} items`);
          legendaryTokenIds = cachedIds;
          
          // Check which ones are minted
          const legendaryStories = cachedIds.map(id => {
            const mintedStory = allStories.find(s => s.id === id);
            
            if (mintedStory) {
              // Use actual metadata for minted legendary
              return mintedStory;
            } else {
              // Use question.svg for unminted legendary
              return {
                id: id,
                title: `Legendary NFT`,
                excerpt: `This legendary NFT #${id} has not been revealed yet.`,
                rarity: 'legendary',
                image: '/assets/monsters/question.svg',
                isLegendary: true
              };
            }
          });
          
          filteredStories = legendaryStories;
          displayStories();
          return;
        }

        // No cache, load from blockchain
        storiesGrid.innerHTML = '<p style="text-align: center; color: #C084FC;">Loading legendary essays...</p>';

        if (!contracts.legendaryBank) {
          if (!await initializeContracts()) {
            storiesGrid.innerHTML = '<p style="text-align: center; color: #EF4444;">Failed to connect to blockchain.</p>';
            return;
          }
        }

        try {
          console.log(`[${new Date().toISOString()}] Starting getLegendaryCount()`);
          const count = await contracts.legendaryBank.getLegendaryCount();
          console.log(`[${new Date().toISOString()}] Completed getLegendaryCount(): ${count.toString()}`);
          const total = count.toNumber();

          if (total === 0) {
            storiesGrid.innerHTML = '<p style="text-align: center; color: #C084FC;">No legendary NFTs registered yet.</p>';
            return;
          }

          legendaryTokenIds = [];
          const legendaryStories = [];

          // Load all legendary token IDs in parallel
          console.log(`[${new Date().toISOString()}] Starting to fetch ${total} legendary IDs in parallel`);
          
          const promises = [];
          for (let i = 0; i < total; i++) {
            promises.push(contracts.legendaryBank.legendaryIds(i));
          }
          
          const tokenIds = await Promise.all(promises);
          console.log(`[${new Date().toISOString()}] Completed fetching all legendary IDs in parallel`);
          
          // Check which ones are minted
          const mintedIds = allStories.map(s => s.id);
          
          // Process results
          for (let index = 0; index < tokenIds.length; index++) {
            const id = tokenIds[index].toNumber();
            legendaryTokenIds.push(id);
            console.log(`legendaryIds(${index}): ${id}`);

            // Check if this legendary is minted
            const mintedStory = allStories.find(s => s.id === id);
            
            if (mintedStory) {
              // Use actual metadata for minted legendary
              legendaryStories.push(mintedStory);
            } else {
              // Use question.svg for unminted legendary
              legendaryStories.push({
                id: id,
                title: `Legendary NFT`,
                excerpt: `This legendary NFT #${id} has not been revealed yet.`,
                rarity: 'legendary',
                image: '/assets/monsters/question.svg',
                isLegendary: true
              });
            }
          }

          // Cache the legendary IDs
          setCachedLegendaryIds(legendaryTokenIds);
          
          filteredStories = legendaryStories;
          displayStories();

        } catch (error) {
          console.error('Failed to load legendary stories:', error);
          storiesGrid.innerHTML = '<p style="text-align: center; color: #EF4444;">Failed to load legendary NFTs.</p>';
        }
      }

      function loadMoreStories() {
        displayCount += 12;
        displayStories();
      }

      // Initial load on page ready
      window.addEventListener('DOMContentLoaded', () => {
        loadAllStories();
      });
    </script>
  </body>
</html>