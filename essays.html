<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Essay Collection - The Mythical Cursed-Nightmare</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="alternate icon" href="favicon.svg" />

    <!-- Apple Touch Icon (180x180 for iOS) -->
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.svg" />

    <!-- PWA対応 -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <!-- Additional Meta Tags -->
    <meta name="theme-color" content="#6B46C1" />
    <meta
      name="description"
      content="Essay Collection - Legendary Tales from the Cursed Realm. Explore the complete anthology of generated essays."
    />

    <link rel="stylesheet" href="css/styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

    <!-- Common utilities and managers -->
    <script src="js/utils/console-override.js"></script>
    <script src="js/utils/format.js"></script>
    <script src="js/wallet/manager.js"></script>
    <script src="js/contracts/manager.js"></script>
    <script src="js/ui/components.js"></script>
    <style>
      .stories-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 20px;
        margin-top: 30px;
      }

      .story-card {
        background: rgba(107, 70, 193, 0.1);
        border: 1px solid rgba(107, 70, 193, 0.3);
        border-radius: 15px;
        padding: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .story-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 30px rgba(147, 51, 234, 0.4);
        border-color: #a78bfa;
      }

      .story-card.legendary {
        background: linear-gradient(45deg, rgba(220, 38, 38, 0.2), rgba(239, 68, 68, 0.2));
        border-color: #ef4444;
      }

      .story-card.epic {
        background: linear-gradient(45deg, rgba(147, 51, 234, 0.2), rgba(167, 139, 250, 0.2));
        border-color: #a78bfa;
      }

      .story-card.rare {
        background: linear-gradient(45deg, rgba(59, 130, 246, 0.2), rgba(96, 165, 250, 0.2));
        border-color: #60a5fa;
      }

      .story-thumbnail {
        width: 100%;
        height: 150px;
        border-radius: 10px;
        object-fit: cover;
        margin-bottom: 15px;
      }

      div.story-thumbnail {
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      div.story-thumbnail svg {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .story-title {
        font-size: 1.3em;
        color: #e9d5ff;
        margin-bottom: 10px;
        font-weight: bold;
      }

      .story-excerpt {
        font-size: 0.9em;
        color: #c084fc;
        line-height: 1.4;
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .story-meta {
        margin-top: 15px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.8em;
        color: #9ca3af;
      }

      .story-id {
        background: rgba(0, 0, 0, 0.3);
        padding: 4px 10px;
        border-radius: 15px;
      }

      .filter-controls {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin: 20px 0;
        flex-wrap: wrap;
      }

      .filter-button {
        background: rgba(107, 70, 193, 0.2);
        border: 1px solid rgba(107, 70, 193, 0.3);
        padding: 8px 20px;
        border-radius: 20px;
        color: #c084fc;
        cursor: pointer;
        transition: all 0.3s;
        font-size: 14px;
      }

      .filter-button:hover {
        background: rgba(107, 70, 193, 0.3);
        color: #e9d5ff;
      }

      .filter-button.active {
        background: linear-gradient(45deg, #6b46c1, #9333ea);
        color: white;
        border-color: transparent;
      }

      .load-more {
        text-align: center;
        margin: 40px 0;
      }

      .story-badge {
        position: absolute;
        top: 10px;
        right: 10px;
        background: linear-gradient(45deg, #ffd700, #ffa500);
        color: #1a0033;
        padding: 4px 10px;
        border-radius: 15px;
        font-size: 0.7em;
        font-weight: bold;
      }

      .story-badge.legendary {
        background: linear-gradient(45deg, #dc2626, #ef4444);
        color: white;
      }

      @media (max-width: 768px) {
        .stories-grid {
          grid-template-columns: 1fr;
          gap: 15px;
        }

        .story-card {
          padding: 15px;
        }

        .story-thumbnail {
          height: 120px;
        }

        .story-title {
          font-size: 1.1em;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Essay Collection</h1>
      <p style="font-size: 20px; color: #ddd; margin-top: 8px; text-align: center; font-weight: 500">
        Legendary Tales from the Cursed Realm
      </p>
      <p style="font-size: 14px; color: #666; margin-top: 15px; text-align: center">
        Explore the complete anthology of generated essays
      </p>

      <div class="button-group">
        <button onclick="window.location.href='generate.html'">← Back to Generator</button>
      </div>

      <div class="filter-controls">
        <button class="filter-button" id="ownFilterBtn" onclick="filterStories('own')" style="display: none">
          Own
        </button>
        <button class="filter-button active" onclick="filterStories('all')">Minted</button>
        <button class="filter-button" onclick="filterStories('rare')">Rare</button>
        <button class="filter-button" onclick="filterStories('epic')">Epic</button>
        <button class="filter-button" onclick="filterStories('trinity')">Trinity</button>
        <button class="filter-button" onclick="filterStories('ultimate')">Ultimate</button>
        <button class="filter-button" onclick="filterStories('legendary')">Legendary</button>
      </div>

      <div id="walletStatus" style="text-align: center; margin-top: 20px; display: none">
        <button id="connectWalletBtn" onclick="connectWallet()" class="legendary-button">Connect Wallet</button>
        <p id="walletAddress" style="color: #a78bfa; margin-top: 10px"></p>
      </div>

      <div id="storiesGrid" class="stories-grid">
        <!-- Stories will be dynamically loaded here -->
      </div>

      <div class="load-more">
        <button onclick="loadMoreStories()" class="nav-button">Load More Essays</button>
      </div>

      <footer style="text-align: center; margin-top: 40px; padding-top: 20px; color: #c084fc; font-size: 14px">
        © 2025 The Mythical Cursed-Nightmare
      </footer>
    </div>

    <script>
      let currentFilter = 'all';
      let loadedStories = [];
      let displayCount = 12;
      let walletManager = null;
      let contractManager = null;
      let provider;
      let userAddress = null;
      let ownedTokenIds = [];
      let mintedTokenIds = [];
      let legendaryTokenIds = [];
      let metadataCache = new Map(); // Cache for loaded metadata
      let currentPage = 0;
      const BATCH_SIZE = 20; // Load 20 NFTs at a time
      let isLoading = false;
      let hasMoreToLoad = true;

      // Load ABI files
      let BANKED_NFT_ABI = null;
      async function loadABIs() {
        try {
          const response = await fetch('/abi/BankedNFT.abi.json');
          if (response.ok) {
            BANKED_NFT_ABI = await response.json();
            console.log(
              'Loaded BankedNFT ABI from file, functions:',
              BANKED_NFT_ABI.filter((item) => item.type === 'function').map((f) => f.name)
            );
            return true;
          }
        } catch (error) {
          console.error('Failed to load ABI file:', error);
        }
        return false;
      }

      // Initialize WalletManager
      async function initializeWalletManager() {
        walletManager = new WalletManager({
          defaultNetwork: 'bonsoleil',
          onConnect: async (account, chainId) => {
            userAddress = account;
            provider = walletManager.getProvider();
            const signer = walletManager.getSigner();

            // Update UI
            document.getElementById('connectWalletBtn').style.display = 'none';
            document.getElementById('walletAddress').textContent = `Connected: ${formatAddress(userAddress)}`;
            document.getElementById('ownFilterBtn').style.display = 'inline-block';

            // Initialize ContractManager with signer
            await initializeContractManager();

            // Load owned NFTs only if on correct network
            if (chainId === 21201) {
              await loadOwnedNFTs();
            } else {
              console.log(`Wrong network for NFT loading. Current: ${chainId}, Required: 21201`);
            }
          },
          onDisconnect: () => {
            userAddress = null;
            provider = null;
            document.getElementById('connectWalletBtn').style.display = 'block';
            document.getElementById('walletAddress').textContent = '';
            document.getElementById('ownFilterBtn').style.display = 'none';
            filterStories('all'); // Reset to all stories
          },
          onAccountChange: async (account) => {
            userAddress = account;
            document.getElementById('walletAddress').textContent = `Connected: ${formatAddress(userAddress)}`;

            // Update ContractManager signer
            if (contractManager) {
              const signer = walletManager.getSigner();
              contractManager.updateSigner(signer);
            }

            // Reload owned NFTs
            await loadOwnedNFTs();
            filterStories(currentFilter);
          },
          onNetworkChange: async (chainId) => {
            console.log('Network changed to:', chainId);
            // Re-load owned NFTs if on correct network
            if (chainId === 21201 && userAddress) {
              await loadOwnedNFTs();
            } else if (userAddress && currentFilter === 'own') {
              // If showing owned NFTs on wrong network, switch to all
              filterStories('all');
              alert('Switched to "All" view. To see your owned NFTs, please switch to Bon-Soleil Testnet.');
            }
          },
        });

        return await walletManager.init();
      }

      // Initialize ContractManager
      async function initializeContractManager() {
        if (!contractManager) {
          contractManager = new ContractManager();
        }
        const signer = walletManager ? walletManager.getSigner() : null;
        await contractManager.initialize(provider, 'deployment', signer);
      }

      // Load blockchain configuration (no longer needed - handled by ContractManager)
      async function loadBlockchainConfig() {
        return true;
      }

      // TEMP - DELETE THIS LONG FUNCTION
      async function loadBlockchainConfig_OLD() {
        // Try to use centralized config first
        if (typeof CONTRACTS_CONFIG !== 'undefined') {
          // Ensure deployment is loaded first
          await CONTRACTS_CONFIG.loadDeployment();

          const network = CONTRACTS_CONFIG.getNetwork(21201); // Bon-Soleil Testnet
          if (network && network.contracts && network.contracts.metadataBank) {
            blockchainConfig = {
              networks: {
                bonsoleil: {
                  name: network.name,
                  rpcUrl: network.rpcUrl,
                  contracts: {
                    metadataBank: {
                      address: network.contracts.metadataBank || network.contracts.MetadataBank,
                      abi: [
                        'function getMetadataCount() view returns (uint256)',
                        'function getMetadata(uint256 index) view returns (string)',
                      ],
                    },
                    bankedNFT: {
                      address: network.contracts.bankedNFT || network.contracts.BankedNFT,
                      abi: [
                        'function balanceOf(address owner) view returns (uint256)',
                        'function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)',
                        'function ownerOf(uint256 tokenId) view returns (address)',
                        'function tokenURI(uint256 tokenId) view returns (string)',
                        'function totalSupply() view returns (uint256)',
                      ],
                    },
                    LegendaryBank: {
                      address: network.contracts.LegendaryBank,
                      abi: [
                        'function getLegendaryCount() view returns (uint256)',
                        'function legendaryIds(uint256 index) view returns (uint256)',
                        'function isLegendaryId(uint256 tokenId) view returns (bool)',
                        'function getLegendaryTitle(uint256 tokenId) view returns (string)',
                        'function getLegendaryDescription(uint256 tokenId) view returns (string)',
                      ],
                    },
                  },
                },
              },
              defaultNetwork: 'bonsoleil',
            };
            console.log('Using centralized contract configuration');
            return true;
          }
        }

        // Try to load deployment.json and setting.json first
        let deployment = null;
        let settings = null;

        try {
          const [deploymentRes, settingRes] = await Promise.all([
            fetch('config/deployment.json'),
            fetch('config/settings.json'),
          ]);

          if (deploymentRes.ok) {
            deployment = await deploymentRes.json();
            console.log('Deployment configuration loaded');
          }

          if (settingRes.ok) {
            settings = await settingRes.json();
            console.log('Settings configuration loaded');
          }

          if (deployment) {
            // Create blockchainConfig from deployment.json and setting.json
            blockchainConfig = {
              networks: {
                bonsoleil: {
                  name: 'Bon-Soleil Testnet',
                  rpcUrl: 'https://dev2.bon-soleil.com/rpc',
                  contracts: {
                    metadataBank: {
                      address: deployment.contracts.MetadataBank,
                      abi: [
                        'function getMetadataCount() view returns (uint256)',
                        'function getMetadata(uint256 index) view returns (string)',
                      ],
                    },
                    bankedNFT: {
                      address: deployment.contracts.BankedNFT,
                      abi: [
                        'function balanceOf(address owner) view returns (uint256)',
                        'function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)',
                        'function ownerOf(uint256 tokenId) view returns (address)',
                        'function tokenURI(uint256 tokenId) view returns (string)',
                        'function totalSupply() view returns (uint256)',
                      ],
                    },
                    LegendaryBank: {
                      address: deployment.contracts.LegendaryBank,
                      abi: [
                        'function getLegendaryCount() view returns (uint256)',
                        'function legendaryIds(uint256 index) view returns (uint256)',
                        'function isLegendaryId(uint256 tokenId) view returns (bool)',
                        'function getLegendaryTitle(uint256 tokenId) view returns (string)',
                        'function getLegendaryDescription(uint256 tokenId) view returns (string)',
                        'function getLegendaryRarity(uint256 tokenId) view returns (uint8)',
                        'function getAllLegendaryIds() view returns (uint256[])',
                      ],
                    },
                  },
                },
              },
              defaultNetwork: 'bonsoleil',
            };
            return true;
          }
        } catch (error) {
          console.error('Failed to load config files:', error);
        }

        // Try to load deployment.json
        try {
          const deploymentResponse = await fetch('config/deployment.json');
          if (deploymentResponse.ok) {
            const deployment = await deploymentResponse.json();
            console.log('Deployment configuration loaded');

            // Create blockchainConfig from deployment.json
            blockchainConfig = {
              networks: {
                bonsoleil: {
                  name: 'Bon-Soleil Testnet',
                  rpcUrl: 'https://dev2.bon-soleil.com/rpc',
                  contracts: {
                    metadataBank: {
                      address: deployment.contracts.MetadataBank,
                      abi: [
                        'function getMetadataCount() view returns (uint256)',
                        'function getMetadata(uint256 index) view returns (string)',
                      ],
                    },
                    bankedNFT: {
                      address: deployment.contracts.BankedNFT,
                      abi: [
                        'function balanceOf(address owner) view returns (uint256)',
                        'function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)',
                        'function ownerOf(uint256 tokenId) view returns (address)',
                        'function tokenURI(uint256 tokenId) view returns (string)',
                        'function totalSupply() view returns (uint256)',
                      ],
                    },
                    legendaryBank: {
                      address: deployment.contracts.LegendaryBank,
                      abi: [
                        'function getLegendaryCount() view returns (uint256)',
                        'function legendaryIds(uint256 index) view returns (uint256)',
                        'function isLegendaryId(uint256 tokenId) view returns (bool)',
                        'function getLegendaryTitle(uint256 tokenId) view returns (string)',
                        'function getLegendaryDescription(uint256 tokenId) view returns (string)',
                      ],
                    },
                  },
                },
              },
              defaultNetwork: 'bonsoleil',
            };
            return true;
          }
        } catch (error) {
          console.error('Failed to load deployment.json:', error);
          throw new Error('Failed to load deployment.json. Contract addresses are required.');
        }

        // deployment.jsonが読み込めない場合はエラー
        throw new Error('deployment.json not found');
      }

      // Generate metadata from blockchain
      async function generateMetadataFromBlockchain(id) {
        try {
          if (!contractManager) {
            throw new Error('ContractManager not initialized');
          }

          const metadataBank = contractManager.getContract('metadataBank');
          if (!metadataBank) {
            throw new Error('MetadataBank contract not found');
          }

          // Use id - 1 as index (no modulo to avoid wrapping)
          const index = Number(id) - 1;
          console.log(`Generating metadata for ID: ${id}, using index: ${index}`);
          let metadataUri = await metadataBank.getMetadata(index);

          // Check if the result is an address (proxy pattern)
          if (metadataUri.startsWith('0x') && metadataUri.length === 42) {
            console.log('MetadataBank returned an address:', metadataUri);
            // Use the same ABI as the main MetadataBank contract
            const metadataBankAbi = contractManager.abis.MetadataBank || [
              'function getMetadata(uint256 index) view returns (string)',
            ];
            const proxyMetadataBank = new ethers.Contract(metadataUri, metadataBankAbi, provider);

            try {
              metadataUri = await proxyMetadataBank.getMetadata(index);
            } catch (proxyError) {
              console.error('Failed to get metadata from proxy contract:', proxyError);
              throw proxyError;
            }
          }

          // Decode the metadata
          let metadata;
          if (metadataUri.startsWith('data:application/json;base64,')) {
            const base64Json = metadataUri.replace('data:application/json;base64,', '');
            const jsonString = atob(base64Json);
            metadata = JSON.parse(jsonString);
          } else if (metadataUri.startsWith('{')) {
            metadata = JSON.parse(metadataUri);
          } else {
            throw new Error('Invalid metadata format');
          }

          // Add the ID to the metadata
          metadata.id = id;

          // Log metadata for debugging
          console.log(`Metadata for ID ${id}:`, {
            id: metadata.id,
            name: metadata.name,
            description: metadata.description?.substring(0, 50) + '...',
          });

          return metadata;
        } catch (error) {
          console.error('Error fetching from blockchain:', error);
          throw error;
        }
      }

      // Load minted NFTs in descending order (newest first)
      async function loadMintedNFTs() {
        try {
          if (!contractManager) {
            console.log('ContractManager not initialized');
            return [];
          }

          const bankedNFTContract = contractManager.getContract('bankedNFT');
          if (!bankedNFTContract) {
            console.log('BankedNFT contract not found');
            return [];
          }

          const totalSupply = await bankedNFTContract.totalSupply();
          console.log(`Total minted NFTs: ${totalSupply.toString()}`);

          mintedTokenIds = [];
          // Load in descending order (newest first)
          for (let i = totalSupply; i >= 1; i--) {
            mintedTokenIds.push(i);
          }

          console.log('Minted token IDs (newest first):', mintedTokenIds.slice(0, 10), '...');
          return mintedTokenIds;
        } catch (error) {
          console.error('Failed to load minted NFTs:', error);
          return [];
        }
      }

      // Load legendary token IDs
      async function loadLegendaryTokenIds() {
        try {
          if (!contractManager) {
            console.log('ContractManager not initialized');
            return [];
          }

          const legendaryBankContract = contractManager.getContract('LegendaryBank');
          if (!legendaryBankContract) {
            console.log('LegendaryBank contract not found');
            return [];
          }

          const count = await legendaryBankContract.getLegendaryCount();
          console.log(`Total legendary tokens: ${count.toString()}`);

          legendaryTokenIds = [];
          for (let i = 0; i < count; i++) {
            const tokenId = await legendaryBankContract.legendaryIds(i);
            legendaryTokenIds.push(Number(tokenId));
          }

          console.log('Legendary token IDs:', legendaryTokenIds);
          return legendaryTokenIds;
        } catch (error) {
          console.error('Failed to load legendary token IDs:', error);
          return [];
        }
      }

      // Initialize with first batch of minted stories
      async function loadRandomStories() {
        const storiesGrid = document.getElementById('storiesGrid');
        storiesGrid.innerHTML = '<p style="text-align: center; color: #C084FC;">Loading essays from blockchain...</p>';

        if (!contractManager) {
          storiesGrid.innerHTML =
            '<p style="text-align: center; color: #EF4444;">Blockchain connection not available. Please refresh the page.</p>';
          return;
        }

        const metadataBank = contractManager.getContract('metadataBank');
        const bankedNFTContract = contractManager.getContract('bankedNFT');

        if (!metadataBank || !bankedNFTContract) {
          storiesGrid.innerHTML =
            '<p style="text-align: center; color: #EF4444;">Contracts not available. Please refresh the page.</p>';
          return;
        }

        // Reset pagination
        currentPage = 0;
        loadedStories = [];
        hasMoreToLoad = true;

        // Load all minted token IDs (but not their metadata yet)
        const minted = await loadMintedNFTs();
        if (minted.length === 0) {
          storiesGrid.innerHTML = '<p style="text-align: center; color: #C084FC;">No NFTs have been minted yet.</p>';
          return;
        }

        // Load legendary token IDs for later use
        await loadLegendaryTokenIds();

        // Load first batch
        await loadNextBatch();
      }

      // Load next batch of stories
      async function loadNextBatch() {
        if (isLoading || !hasMoreToLoad) return;

        isLoading = true;
        const storiesGrid = document.getElementById('storiesGrid');

        try {
          let tokenIdsToLoad = [];

          if (currentFilter === 'all') {
            // For "Minted", load next batch of minted NFTs (newest first)
            const start = currentPage * BATCH_SIZE;
            const end = Math.min(start + BATCH_SIZE, mintedTokenIds.length);
            tokenIdsToLoad = mintedTokenIds.slice(start, end);
            hasMoreToLoad = end < mintedTokenIds.length;
          } else if (currentFilter === 'legendary') {
            // For "Legendary", already loaded all
            hasMoreToLoad = false;
            return;
          } else if (currentFilter === 'own') {
            // For "Own", already loaded all
            hasMoreToLoad = false;
            return;
          } else {
            // For other filters (rare, epic, trinity, ultimate), they filter from minted NFTs
            // So no separate loading needed
            hasMoreToLoad = false;
            return;
          }

          if (tokenIdsToLoad.length === 0) {
            hasMoreToLoad = false;
            isLoading = false;
            return;
          }

          // Show loading indicator
          if (currentPage === 0) {
            storiesGrid.innerHTML = '<p style="text-align: center; color: #C084FC;">Loading essays...</p>';
          }

          // Load metadata for batch
          const promises = tokenIdsToLoad.map((tokenId) => {
            // Check cache first
            if (metadataCache.has(tokenId)) {
              return Promise.resolve(metadataCache.get(tokenId));
            }
            return generateMetadataFromBlockchain(tokenId).then((metadata) => {
              metadataCache.set(tokenId, metadata);
              return metadata;
            });
          });

          const batchStories = await Promise.all(promises);
          loadedStories = [...loadedStories, ...batchStories];

          currentPage++;
          displayStories();
        } catch (error) {
          console.error('Failed to load batch:', error);
          if (currentPage === 0) {
            storiesGrid.innerHTML =
              '<p style="text-align: center; color: #EF4444;">Failed to load essays. Please try again.</p>';
          }
        } finally {
          isLoading = false;
        }
      }

      // Display stories based on current filter
      function displayStories() {
        const storiesGrid = document.getElementById('storiesGrid');
        storiesGrid.innerHTML = '';

        const filteredStories = filterStoriesByType(loadedStories, currentFilter);
        const storiesToShow = filteredStories.slice(0, displayCount);

        if (storiesToShow.length === 0) {
          storiesGrid.innerHTML =
            '<p style="text-align: center; color: #C084FC; grid-column: 1/-1;">No essays found for this filter.</p>';
          return;
        }

        storiesToShow.forEach((story) => {
          const storyCard = createStoryCard(story);
          storiesGrid.appendChild(storyCard);
        });
      }

      // Filter stories by type
      function filterStoriesByType(stories, filter) {
        if (filter === 'all') return stories;

        if (filter === 'own') {
          // Filter to show only owned NFTs
          console.log('Filtering for owned NFTs. OwnedTokenIds:', ownedTokenIds);
          return stories.filter((story) => {
            const tokenId = parseInt(story.id);
            const isOwned = ownedTokenIds.includes(tokenId);
            if (story.id <= 10) {
              // Log first 10 for debugging
              console.log(`Story ID: ${story.id}, TokenID: ${tokenId}, Owned: ${isOwned}`);
            }
            return isOwned;
          });
        }

        if (filter === 'legendary') {
          // Filter to show only legendary NFTs from LegendaryBank
          return stories.filter((story) => {
            const tokenId = parseInt(story.id);
            return legendaryTokenIds.includes(tokenId);
          });
        }

        return stories.filter((story) => {
          const rarity = story.attributes.find((a) => a.trait_type === 'Rarity')?.value?.toLowerCase() || 'common';

          switch (filter) {
            case 'epic':
              return rarity === 'epic';
            case 'rare':
              return rarity === 'rare';
            case 'trinity':
              return rarity === 'trinity';
            case 'ultimate':
              return rarity === 'ultimate';
            default:
              return true;
          }
        });
      }

      // Create story card element
      function createStoryCard(story) {
        const card = document.createElement('div');
        const rarity = story.attributes.find((a) => a.trait_type === 'Rarity')?.value?.toLowerCase() || 'common';
        const isSpecial = story.attributes.find((a) => a.trait_type === 'Special');
        const isLegendary = story.attributes.find((a) => a.trait_type === 'Legendary');

        card.className = `story-card ${rarity}`;

        // Use the ID directly from the story object
        const storyId = story.id || '1';

        // Create badge HTML
        let badgeHtml = '';
        if (isLegendary) {
          badgeHtml = '<div class="story-badge legendary">⚡ LEGENDARY</div>';
        } else if (isSpecial) {
          badgeHtml = '<div class="story-badge">✨ SPECIAL</div>';
        }

        // Create image HTML with SVG support
        let imageHtml = '';
        if (story.image && story.image.startsWith('data:image/svg+xml;base64,')) {
          try {
            const base64Svg = story.image.replace('data:image/svg+xml;base64,', '');
            const svg = atob(base64Svg);
            // Wrap SVG in a div to control sizing
            imageHtml = `<div class="story-thumbnail">${svg}</div>`;
          } catch (e) {
            console.error('Failed to decode SVG:', e);
            // Fallback to img tag
            imageHtml = `<img src="${story.image}" alt="${story.name}" class="story-thumbnail">`;
          }
        } else {
          // For non-base64 SVG images, use img tag
          imageHtml = `<img src="${story.image}" alt="${story.name}" class="story-thumbnail">`;
        }

        // Always add token ID to the display name for consistency
        const displayName = `${story.name} #${storyId}`;

        card.innerHTML = `
          ${badgeHtml}
          ${imageHtml}
          <div class="story-title">${displayName}</div>
          <div class="story-excerpt">${story.description}</div>
          <div class="story-meta">
            <span class="story-id">ID: ${storyId}</span>
            <span>${rarity.charAt(0).toUpperCase() + rarity.slice(1)}</span>
          </div>
        `;

        card.onclick = () => {
          window.location.href = `generate.html?id=${storyId}`;
        };

        return card;
      }

      // Connect wallet function
      async function connectWallet() {
        try {
          await walletManager.connect('bonsoleil');
        } catch (error) {
          console.error('Failed to connect wallet:', error);
          alert('Failed to connect wallet');
        }
      }

      // Load owned NFTs
      async function loadOwnedNFTs() {
        if (!userAddress || !contractManager) {
          console.log('Cannot load NFTs - userAddress:', userAddress, 'contractManager:', contractManager);
          return;
        }

        let bankedNFTContract = contractManager.getContract('bankedNFT');

        // If we have the full ABI loaded, create a new contract instance
        if (BANKED_NFT_ABI && BANKED_NFT_ABI.length > 30) {
          console.log('Creating BankedNFT contract with loaded ABI');
          const deployment = await (await fetch('/config/deployment.json')).json();
          const bankedNftAddress = deployment.contracts.BankedNFT;
          bankedNFTContract = new ethers.Contract(bankedNftAddress, BANKED_NFT_ABI, provider);
        } else if (!bankedNFTContract) {
          console.log('BankedNFT contract not found and no ABI loaded');
          return;
        }

        console.log('BankedNFT contract:', bankedNFTContract);
        console.log('Has tokenOfOwnerByIndex:', typeof bankedNFTContract.tokenOfOwnerByIndex === 'function');
        console.log('Contract functions:', Object.keys(bankedNFTContract.functions || {}));

        try {
          console.log('Loading NFTs for address:', userAddress);
          const balance = await bankedNFTContract.balanceOf(userAddress);
          console.log('Balance:', balance.toString());

          ownedTokenIds = [];

          // Use ERC721Enumerable tokenOfOwnerByIndex
          for (let i = 0; i < balance; i++) {
            try {
              const tokenId = await bankedNFTContract.tokenOfOwnerByIndex(userAddress, i);
              const tokenIdNumber = tokenId.toNumber();
              ownedTokenIds.push(tokenIdNumber);
              console.log(`Found owned token at index ${i}: ${tokenIdNumber}`);
            } catch (error) {
              console.error(`Error getting token at index ${i}:`, error);
            }
          }

          console.log(`User owns ${ownedTokenIds.length} NFTs:`, ownedTokenIds);

          // Load the metadata for owned NFTs
          if (ownedTokenIds.length > 0 && currentFilter === 'own') {
            await loadOwnedNFTsMetadata();
          }
        } catch (error) {
          console.error('Failed to load owned NFTs:', error);
          console.error('Error details:', error.message);

          // Don't show alert for CALL_EXCEPTION errors, just log
          if (error.code === 'CALL_EXCEPTION') {
            console.log('Contract not available on current network');
            ownedTokenIds = []; // Clear owned tokens
          }
        }
      }

      // Load metadata for owned NFTs
      async function loadOwnedNFTsMetadata() {
        const promises = ownedTokenIds.map((tokenId) => generateMetadataFromBlockchain(tokenId));

        try {
          const ownedStories = await Promise.all(promises);
          // Replace loadedStories with owned stories when viewing "own" filter
          if (currentFilter === 'own') {
            loadedStories = ownedStories;
            displayStories();
          }
        } catch (error) {
          console.error('Failed to load owned NFT metadata:', error);
        }
      }

      // Filter stories
      async function filterStories(filter) {
        const previousFilter = currentFilter;
        currentFilter = filter;
        displayCount = 12;

        // Update active button
        document.querySelectorAll('.filter-button').forEach((btn) => {
          btn.classList.remove('active');
        });
        event.target.classList.add('active');

        // Show wallet connection status for "Own" filter
        const walletStatus = document.getElementById('walletStatus');
        if (filter === 'own') {
          walletStatus.style.display = 'block';
          if (!userAddress) {
            document.getElementById('storiesGrid').innerHTML =
              '<p style="text-align: center; color: #A78BFA;">Please connect your wallet to view your NFTs</p>';
            return;
          }
        } else {
          walletStatus.style.display = 'none';
        }

        // Reset pagination when switching filters
        if (filter !== previousFilter) {
          currentPage = 0;
          hasMoreToLoad = true;
        }

        // For legendary filter, load all legendary NFTs (minted or not)
        if (filter === 'legendary' && legendaryTokenIds.length > 0) {
          const storiesGrid = document.getElementById('storiesGrid');
          storiesGrid.innerHTML = '<p style="text-align: center; color: #C084FC;">Loading legendary essays...</p>';

          // Use cache for legendary NFTs too
          const promises = legendaryTokenIds.map((tokenId) => {
            if (metadataCache.has(tokenId)) {
              return Promise.resolve(metadataCache.get(tokenId));
            }
            return generateMetadataFromBlockchain(tokenId).then((metadata) => {
              metadataCache.set(tokenId, metadata);
              return metadata;
            });
          });

          try {
            loadedStories = await Promise.all(promises);
            displayStories();
          } catch (error) {
            console.error('Failed to load legendary stories:', error);
            displayStories();
          }
        } else if (filter === 'all' && currentPage === 0) {
          // For "Minted", load first batch
          loadedStories = [];
          await loadNextBatch();
        } else {
          displayStories();
        }
      }

      // Load more stories
      async function loadMoreStories() {
        if (currentFilter === 'all' && hasMoreToLoad) {
          // For "Minted", load next batch from blockchain
          await loadNextBatch();
        } else {
          // For other filters, just show more of already loaded stories
          displayCount += 12;
          displayStories();
        }
      }

      // Load stories on page load
      window.addEventListener('DOMContentLoaded', async () => {
        // Initialize UI Components
        initializeUIStyles();

        // Load ABIs first
        await loadABIs();

        // Initialize WalletManager
        await initializeWalletManager();

        // Initialize provider for read-only operations
        if (!provider) {
          // ethers v5
          provider = new ethers.providers.JsonRpcProvider('https://dev2.bon-soleil.com/rpc');
          console.log('Initialized JsonRpcProvider for read-only operations');
        }

        // Initialize ContractManager with provider
        if (!contractManager) {
          contractManager = new ContractManager();
        }
        await contractManager.initialize(provider, 'deployment', null); // null signer for read-only
        console.log('ContractManager initialized with provider');

        // Check if wallet already connected
        if (walletManager && walletManager.isWalletConnected()) {
          provider = walletManager.getProvider();
          const signer = walletManager.getSigner();
          if (signer) {
            contractManager.updateSigner(signer);
          }
        }

        // Load legendary token IDs
        await loadLegendaryTokenIds();

        // Check if wallet status should be shown (for 'own' filter)
        const walletStatus = document.getElementById('walletStatus');
        if (currentFilter === 'own') {
          walletStatus.style.display = 'block';
        }

        // Load first batch of stories
        loadRandomStories();
      });
    </script>
  </body>
</html>
