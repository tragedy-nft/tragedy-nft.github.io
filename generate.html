<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>The Mythical Cursed-Nightmare: Essays on Generative Tragedy</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="alternate icon" href="favicon.svg" />

    <!-- Apple Touch Icon (180x180 for iOS) -->
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.svg" />

    <!-- PWAÂØæÂøú -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <!-- Additional Meta Tags -->
    <meta name="theme-color" content="#6B46C1" />
    <meta name="description" content="View NFT details from The Mythical Cursed-Nightmare collection." />

    <link rel="stylesheet" href="css/styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
      .nft-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }

      .nft-image {
        width: 100%;
        max-width: 400px;
        margin: 20px auto;
        display: block;
        border-radius: 15px;
        border: 2px solid rgba(147, 51, 234, 0.3);
      }

      div.nft-image {
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      div.nft-image svg {
        width: 100%;
        height: auto;
        max-height: 400px;
      }

      .nft-title {
        font-size: 2em;
        color: #e9d5ff;
        margin: 20px 0;
        text-align: center;
      }

      .nft-description {
        color: #c084fc;
        line-height: 1.6;
        margin: 20px 0;
        text-align: center;
      }

      .nft-attributes {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        margin: 30px 0;
      }

      .attribute-card {
        background: rgba(107, 70, 193, 0.1);
        border: 1px solid rgba(107, 70, 193, 0.3);
        border-radius: 10px;
        padding: 15px;
        text-align: center;
      }

      .attribute-label {
        color: #9ca3af;
        font-size: 0.8em;
        text-transform: uppercase;
      }

      .attribute-value {
        color: #e9d5ff;
        font-size: 1.2em;
        margin-top: 5px;
        font-weight: bold;
      }

      .legendary-section {
        margin-top: 50px;
        padding: 30px;
        background: linear-gradient(45deg, rgba(220, 38, 38, 0.1), rgba(239, 68, 68, 0.1));
        border: 2px solid #ef4444;
        border-radius: 15px;
      }

      .owner-section {
        margin-top: 10px;
        padding: 20px;
        background: rgba(107, 70, 193, 0.1);
        border: 1px solid rgba(107, 70, 193, 0.3);
        border-radius: 15px;
        text-align: center;
      }

      .owner-label {
        color: #9ca3af;
        font-size: 0.9em;
        margin-bottom: 10px;
      }

      .owner-address {
        color: #e9d5ff;
        font-family: monospace;
        font-size: 1.1em;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .copy-button {
        background: rgba(107, 70, 193, 0.2);
        border: 1px solid rgba(107, 70, 193, 0.3);
        color: #c084fc;
        padding: 5px 10px;
        border-radius: 15px;
        cursor: pointer;
        font-size: 0.8em;
        transition: all 0.3s;
      }

      .copy-button:hover {
        background: rgba(107, 70, 193, 0.4);
        color: #e9d5ff;
      }

      .copy-button.copied {
        background: rgba(34, 197, 94, 0.3);
        border-color: rgba(34, 197, 94, 0.5);
        color: #4ade80;
      }

      .opensea-link {
        display: inline-block;
        background: linear-gradient(45deg, #2975ca, #2e8de6);
        color: white;
        padding: 10px 20px;
        border-radius: 25px;
        text-decoration: none;
        transition: all 0.3s;
        font-size: 0.9em;
      }

      .opensea-link:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(41, 117, 202, 0.4);
      }

      .legendary-title {
        color: #ef4444;
        font-size: 1.5em;
        margin-bottom: 20px;
        text-align: center;
      }

      .legendary-ids {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
      }

      .legendary-id {
        background: rgba(0, 0, 0, 0.5);
        color: #ef4444;
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 0.9em;
        text-decoration: none;
        display: inline-block;
      }

      a.legendary-id {
        transition: all 0.3s;
      }

      a.legendary-id:hover {
        background: rgba(239, 68, 68, 0.3);
        transform: translateY(-2px);
      }

      .loading {
        text-align: center;
        color: #c084fc;
        margin: 50px 0;
      }

      .error {
        text-align: center;
        color: #ef4444;
        margin: 50px 0;
      }

      @media (max-width: 768px) {
        .nft-title {
          font-size: 1.5em;
        }

        .nft-attributes {
          grid-template-columns: 1fr 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>The Mythical Cursed-Nightmare</h1>
      <p style="font-size: 15px; color: #ddd; margin-top: 4px; text-align: center; font-weight: 500">
        Essays on Generative Tragedy
      </p>
      <p style="font-size: 13px; color: #666; margin-top: 4px; text-align: center">
        Discover legendary tales and hidden tragedies.
      </p>

      <div class="button-group">
        <button onclick="window.location.href='essays.html'">‚Üê Back to Collection</button>
      </div>

      <div id="nftContainer" class="nft-container">
        <div class="loading">Loading NFT data...</div>
      </div>

      <div id="ownerSection" class="owner-section" style="display: none">
        <div class="owner-label">Current Owner</div>
        <div id="ownerAddress" class="owner-address">Loading...</div>
        <a id="openseaLink" href="#" target="_blank" class="opensea-link">View on OpenSea</a>
      </div>

      <div id="legendarySection" class="legendary-section" style="display: none">
        <div class="legendary-title">üî• Legendary IDs</div>
        <div id="legendaryIds" class="legendary-ids"></div>
      </div>
    </div>

    <script>
      // Configuration
      const CACHE_KEY = 'mythOfTragedy_essays';
      const LEGENDARY_CACHE_KEY = 'mythOfTragedy_legendary';
      let provider = null;
      let contracts = {};

      // Get URL parameters
      function getUrlParameter(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
      }

      // Initialize contracts
      async function initializeContracts() {
        try {
          const [blockchainResponse, deploymentResponse] = await Promise.all([
            fetch('/config/blockchain.json'),
            fetch('/config/deployment.json'),
          ]);

          if (!blockchainResponse.ok || !deploymentResponse.ok) {
            throw new Error('Failed to load configurations');
          }

          const blockchainConfig = await blockchainResponse.json();
          const deployment = await deploymentResponse.json();

          const defaultNetwork = blockchainConfig.defaultNetwork;
          const networkConfig = blockchainConfig.networks[defaultNetwork];

          provider = new ethers.providers.JsonRpcProvider(networkConfig.rpcUrl);

          const metadataBankAbi = ['function getMetadata(uint256 index) view returns (string)'];

          const bankedNFTAbi = ['function ownerOf(uint256 tokenId) view returns (address)'];

          contracts.metadataBank = new ethers.Contract(deployment.contracts.MetadataBank, metadataBankAbi, provider);

          contracts.bankedNFT = new ethers.Contract(deployment.contracts.BankedNFT, bankedNFTAbi, provider);

          contracts.bankedNFTAddress = deployment.contracts.BankedNFT;

          return true;
        } catch (error) {
          console.error('Failed to initialize contracts:', error);
          return false;
        }
      }

      // Get NFT metadata from cache or contract
      async function getNFTMetadata(tokenId) {
        // Check cache first
        try {
          const cached = localStorage.getItem(CACHE_KEY);
          if (cached) {
            const data = JSON.parse(cached);
            const story = data.stories.find((s) => s.id === parseInt(tokenId));
            if (story) {
              return story;
            }
          }
        } catch (error) {
          console.error('Cache read error:', error);
        }

        // Load from contract
        if (!contracts.metadataBank) {
          if (!(await initializeContracts())) {
            throw new Error('Failed to initialize contracts');
          }
        }

        const index = Number(tokenId) - 1;
        let metadataUri = await contracts.metadataBank.getMetadata(index);

        // Handle proxy pattern
        if (metadataUri.startsWith('0x') && metadataUri.length === 42) {
          const metadataBankAbi = ['function getMetadata(uint256 index) view returns (string)'];
          const proxyMetadataBank = new ethers.Contract(metadataUri, metadataBankAbi, provider);
          metadataUri = await proxyMetadataBank.getMetadata(index);
        }

        // Decode metadata
        let metadata;
        if (metadataUri.startsWith('data:application/json;base64,')) {
          const base64Json = metadataUri.replace('data:application/json;base64,', '');
          const jsonString = atob(base64Json);
          metadata = JSON.parse(jsonString);
        } else if (metadataUri.startsWith('{')) {
          metadata = JSON.parse(metadataUri);
        } else {
          throw new Error('Invalid metadata format');
        }

        // Convert to story format
        const rarity = metadata.attributes?.find((a) => a.trait_type === 'Rarity')?.value?.toLowerCase() || 'common';
        const isLegendary = metadata.attributes?.find((a) => a.trait_type === 'Legendary') !== undefined;

        return {
          id: tokenId,
          title: metadata.name.replace(/#\d+$/, '').trim(),
          excerpt: metadata.description,
          rarity: rarity,
          image: metadata.image,
          isLegendary: isLegendary,
          attributes: metadata.attributes,
        };
      }

      // Display NFT details
      function displayNFT(nft) {
        const container = document.getElementById('nftContainer');

        let imageHtml = '';
        if (nft.image && nft.image.startsWith('data:image/svg+xml;base64,')) {
          try {
            const base64Svg = nft.image.replace('data:image/svg+xml;base64,', '');
            const svg = atob(base64Svg);
            imageHtml = `<div class="nft-image">${svg}</div>`;
          } catch (e) {
            imageHtml = `<img src="${nft.image}" alt="${nft.title}" class="nft-image">`;
          }
        } else {
          imageHtml = `<img src="${nft.image}" alt="${nft.title}" class="nft-image">`;
        }

        container.innerHTML = `
          ${imageHtml}
          <h2 class="nft-title">#${nft.id} ${nft.title}</h2>
          <p class="nft-description">${nft.excerpt}</p>

          <div class="nft-attributes">
            ${
              nft.attributes
                ? nft.attributes
                    .map(
                      (attr) => `
              <div class="attribute-card">
                <div class="attribute-label">${attr.trait_type}</div>
                <div class="attribute-value">${attr.value}</div>
              </div>
            `
                    )
                    .join('')
                : ''
            }
          </div>
        `;
      }

      // Display legendary IDs
      function displayLegendaryIds() {
        try {
          const cached = localStorage.getItem(LEGENDARY_CACHE_KEY);
          if (!cached) return;

          const data = JSON.parse(cached);
          const legendaryIds = data.tokenIds;

          if (!legendaryIds || legendaryIds.length === 0) return;

          // Get minted NFT data from cache
          let mintedStories = [];
          try {
            const essaysCached = localStorage.getItem(CACHE_KEY);
            if (essaysCached) {
              const essaysData = JSON.parse(essaysCached);
              mintedStories = essaysData.stories || [];
            }
          } catch (e) {
            console.error('Failed to load minted stories:', e);
          }

          const container = document.getElementById('legendaryIds');
          container.innerHTML = legendaryIds
            .map((id) => {
              const mintedStory = mintedStories.find((s) => s.id === parseInt(id));
              if (mintedStory) {
                // Show name with link for minted legendary
                return `<a href="generate.html?id=${id}" class="legendary-id">#${id} ${mintedStory.title}</a>`;
              } else {
                // Show only ID for unminted
                return `<span class="legendary-id">#${id}</span>`;
              }
            })
            .join('');

          document.getElementById('legendarySection').style.display = 'block';
        } catch (error) {
          console.error('Failed to load legendary IDs:', error);
        }
      }

      // Get owner information
      async function getOwnerInfo(tokenId) {
        try {
          if (!contracts.bankedNFT) {
            if (!(await initializeContracts())) {
              throw new Error('Failed to initialize contracts');
            }
          }

          const owner = await contracts.bankedNFT.ownerOf(tokenId);
          return owner;
        } catch (error) {
          console.error('Failed to get owner:', error);
          return null;
        }
      }

      // Format address to short form
      function formatAddress(address) {
        if (!address) return '';
        return `${address.slice(0, 8)}...${address.slice(-6)}`;
      }

      // Copy to clipboard
      async function copyToClipboard(text) {
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch (err) {
          console.error('Failed to copy:', err);
          return false;
        }
      }

      // Display owner information
      async function displayOwnerInfo(tokenId) {
        const owner = await getOwnerInfo(tokenId);
        if (owner) {
          // Create address display with copy button
          const ownerContainer = document.getElementById('ownerAddress');
          ownerContainer.innerHTML = `
            <span>${formatAddress(owner)}</span>
            <button class="copy-button" onclick="handleCopy('${owner}', this)">Copy</button>
          `;

          // Store full address for copy function
          window.fullOwnerAddress = owner;

          // OpenSea link for Polygon
          const openseaUrl = `https://opensea.io/assets/matic/${contracts.bankedNFTAddress}/${tokenId}`;
          document.getElementById('openseaLink').href = openseaUrl;

          document.getElementById('ownerSection').style.display = 'block';
        }
      }

      // Handle copy button click
      async function handleCopy(address, button) {
        const success = await copyToClipboard(address);
        if (success) {
          button.textContent = 'Copied!';
          button.classList.add('copied');
          setTimeout(() => {
            button.textContent = 'Copy';
            button.classList.remove('copied');
          }, 2000);
        }
      }

      // Load NFT on page load
      window.addEventListener('DOMContentLoaded', async () => {
        const tokenId = getUrlParameter('id');

        if (!tokenId) {
          document.getElementById('nftContainer').innerHTML =
            '<div class="error">No NFT ID specified. <a href="essays.html">Back to collection</a></div>';
          return;
        }

        try {
          const nft = await getNFTMetadata(tokenId);
          displayNFT(nft);
          displayLegendaryIds();

          // Display owner info for minted NFTs
          await displayOwnerInfo(tokenId);
        } catch (error) {
          console.error('Failed to load NFT:', error);
          document.getElementById('nftContainer').innerHTML =
            '<div class="error">Failed to load NFT data. <a href="essays.html">Back to collection</a></div>';
        }
      });
    </script>
  </body>
</html>
