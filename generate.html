<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>The Mythical Cursed-Nightmare: Essays on Generative Tragedy</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="alternate icon" href="favicon.svg" />

    <!-- Apple Touch Icon (180x180 for iOS) -->
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.svg" />

    <!-- PWA対応 -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <!-- Additional Meta Tags -->
    <meta name="theme-color" content="#6B46C1" />
    <meta
      name="description"
      content="The Mythical Cursed-Nightmare - Essays on Generative Tragedy. Discover legendary tales and hidden tragedies in this NFT collection."
    />

    <link rel="stylesheet" href="css/styles.css" />
    <script src="js/utils/console-override.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

    <!-- Contract Manager -->
    <script src="js/wallet/manager.js"></script>
    <script src="js/contracts/manager.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>The Mythical Cursed-Nightmare</h1>
      <p style="font-size: 15px; color: #ddd; margin-top: 4px; text-align: center; font-weight: 500">
        Essays on Generative Tragedy
      </p>
      <p style="font-size: 13px; color: #666; margin-top: 4px; text-align: center">
        Discover legendary tales and hidden tragedies.
      </p>

      <div class="button-group">
        <button onclick="generateSingle()">Generate</button>
        <button
          onclick="window.location.href='story.html'"
          style="background: linear-gradient(45deg, #7b2d43, #9b1b5a)"
        >
          Narrative
        </button>
        <button onclick="window.location.href='essays.html'" class="nav-button">Collection</button>
      </div>

      <div id="metadataDisplay" class="metadata-display"></div>

      <div class="id-controls">
        <div class="id-controls-inner">
          <input type="number" id="idInput" placeholder="ID" min="1" max="10000" />
          <button onclick="generateById()" class="generate-button">Generate</button>
          <div class="nav-buttons">
            <button onclick="generatePrev()" class="nav-button">Prev</button>
            <button onclick="generateNext()" class="nav-button">Next</button>
          </div>
        </div>
      </div>

      <div class="legendary-ids">
        <h3>🔥 Legendary IDs</h3>
        <div class="legendary-ids-list" id="legendaryIdsList">
          <!-- Legendary IDs will be loaded dynamically -->
          <p style="text-align: center; color: #c084fc">Loading legendary IDs...</p>
        </div>
      </div>

      <footer style="text-align: center; margin-top: 40px; padding-top: 20px; color: #c084fc; font-size: 14px">
        © 2025 The Mythical Cursed-Nightmare
        <a
          href="http://bon-soleil.com"
          target="_blank"
          rel="noopener noreferrer"
          style="color: #c084fc; text-decoration: none; transition: color 0.3s"
          onmouseover="this.style.color='#E9D5FF'"
          onmouseout="this.style.color='#C084FC'"
          >bonsoleil</a
        >
      </footer>
    </div>

    <script>
      let currentMetadata = [];
      let provider;
      let metadataBank;
      let legendaryBankContract;
      let contractManager = null;
      let blockchainConfig = null;
      let isInitialized = false;
      
      // Initialize on page load
      document.addEventListener('DOMContentLoaded', async () => {
        try {
          if (window.ethereum) {
            // Check if we need to switch to Amoy network
            const deploymentResponse = await fetch('/config/deployment.json');
            if (deploymentResponse.ok) {
              const deployment = await deploymentResponse.json();
              if (deployment.network) {
                const match = deployment.network.match(/chain-(\d+)/);
                if (match) {
                  const targetChainId = parseInt(match[1], 10);
                  
                  // Get current network
                  const currentChainId = parseInt(await window.ethereum.request({ method: 'eth_chainId' }), 16);
                  
                  if (currentChainId !== targetChainId) {
                    try {
                      await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: `0x${targetChainId.toString(16)}` }]
                      });
                    } catch (error) {
                      console.error('Failed to switch network:', error);
                    }
                  }
                }
              }
            }
            
            // Initialize ContractManager
            contractManager = new ContractManager();
            // Try using JsonRpcProvider directly instead of Web3Provider
            let provider;
            try {
              // First try with JsonRpcProvider for Amoy
              provider = new ethers.providers.JsonRpcProvider('https://rpc-amoy.polygon.technology/');
              const network = await provider.getNetwork();
              console.log('Using JsonRpcProvider, network:', network.chainId);
            } catch (e) {
              // Fallback to Web3Provider
              console.log('JsonRpcProvider failed, using Web3Provider');
              provider = new ethers.providers.Web3Provider(window.ethereum);
            }
            await contractManager.initialize(provider, 'deployment');
            console.log('ContractManager initialized, networkId:', contractManager.networkId);
            
            // Initialize blockchain connection
            await loadBlockchainConfig();
            const initialized = await initBlockchain();
            if (initialized) {
              isInitialized = true;
              console.log('Blockchain connection initialized');
            }
          }
        } catch (error) {
          console.error('Failed to initialize:', error);
        }
      });

      // Load blockchain configuration
      async function loadBlockchainConfig() {
        // Use ContractManager to get contract addresses and network info
        if (contractManager && contractManager.networkId) {
          const metadataBankAddress = contractManager.getContractAddress('metadataBank');
          const legendaryBankAddress = contractManager.getContractAddress('LegendaryBank');
          
          // Get network configuration from blockchain.json
          const blockchainConfigResponse = await fetch('/config/blockchain.json');
          if (blockchainConfigResponse.ok) {
            const fullConfig = await blockchainConfigResponse.json();
            
            // Find the network configuration that matches the current chain ID
            const networkEntry = Object.entries(fullConfig.networks).find(
              ([key, net]) => net.chainId === contractManager.networkId
            );
            
            if (networkEntry) {
              const [networkKey, networkConfig] = networkEntry;
              
              blockchainConfig = {
                networks: {
                  [networkKey]: {
                    name: networkConfig.name,
                    rpcUrl: networkConfig.rpcUrl,
                    chainId: networkConfig.chainId,
                    contracts: {
                      metadataBank: {
                        address: metadataBankAddress,
                      abi: [
                        'function getMetadataCount() view returns (uint256)',
                        'function getMetadata(uint256 index) view returns (string)',
                        'function composer() view returns (address)',
                        'function decodeTokenId(uint256 tokenId) view returns (uint8 species, uint8 background, uint8 item, uint8 effect)',
                        'function generateMetadata(uint256 tokenId, uint8 species, uint8 background, uint8 item, uint8 effect) view returns (string)',
                      ],
                    },
                    LegendaryBank: {
                      address: legendaryBankAddress,
                    },
                  },
                },
              },
              defaultNetwork: networkKey,
            };
            console.log(`Using ContractManager configuration for ${networkConfig.name}`);
            return true;
            }
          }
        }

        // Try to load deployment.json first
        try {
          const deploymentResponse = await fetch('config/deployment.json');
          if (deploymentResponse.ok) {
            const deployment = await deploymentResponse.json();
            console.log('Deployment configuration loaded');

            // Create blockchainConfig from deployment.json
            blockchainConfig = {
              networks: {
                bonsoleil: {
                  name: 'Bon-Soleil Testnet',
                  rpcUrl: 'https://dev2.bon-soleil.com/rpc',
                  contracts: {
                    metadataBank: {
                      address: deployment.contracts.MetadataBank,
                      abi: [
                        'function getMetadataCount() view returns (uint256)',
                        'function getMetadata(uint256 index) view returns (string)',
                        'function composer() view returns (address)',
                        'function decodeTokenId(uint256 tokenId) view returns (uint8 species, uint8 background, uint8 item, uint8 effect)',
                        'function generateMetadata(uint256 tokenId, uint8 species, uint8 background, uint8 item, uint8 effect) view returns (string)',
                      ],
                    },
                    LegendaryBank: {
                      address: deployment.contracts.LegendaryBank,
                    },
                  },
                },
              },
              defaultNetwork: 'bonsoleil',
            };
            return true;
          }
        } catch (error) {
          console.error('Failed to load deployment.json:', error);
          throw new Error('Failed to load deployment.json. Contract addresses are required.');
        }

        // deployment.jsonが読み込めない場合はエラー
        throw new Error('deployment.json not found');
      }

      // Initialize blockchain connection
      async function initBlockchain() {
        try {
          // Return true if already initialized
          if (isInitialized && metadataBank) {
            return true;
          }
          
          if (typeof ethers === 'undefined') {
            alert('ethers.js library not loaded. Please check your internet connection.');
            return false;
          }

          // Use ContractManager for all contract interactions
          if (!contractManager || !contractManager.networkId) {
            console.error('ContractManager not initialized or network not set');
            return false;
          }

          // Get the provider from ContractManager
          provider = contractManager.provider;
          const networkId = contractManager.networkId;
          
          console.log(`Using network ID: ${networkId}`);

          // Get MetadataBank contract from ContractManager
          metadataBank = contractManager.getContract('metadataBank');
          if (!metadataBank) {
            console.error('MetadataBank contract not found in ContractManager');
            return false;
          }

          const metadataBankAddress = contractManager.getContractAddress('metadataBank');
          console.log(`MetadataBank address: ${metadataBankAddress}`);

          // Get LegendaryBank contract from ContractManager
          legendaryBankContract = contractManager.getContract('LegendaryBank');
          if (!legendaryBankContract) {
            console.warn('LegendaryBank contract not found in ContractManager');
          } else {
            const legendaryBankAddress = contractManager.getContractAddress('LegendaryBank');
            console.log(`LegendaryBank address: ${legendaryBankAddress}`);
          }

          // Test connection - but don't fail if getMetadataCount doesn't work
          try {
            const count = await metadataBank.getMetadataCount();
            console.log('MetadataBank total metadata:', count.toString());
          } catch (error) {
            console.log('getMetadataCount not available, but contract may still work');
          }

          return true;
        } catch (error) {
          console.error('Failed to connect to blockchain:', error);
          return false;
        }
      }

      // Generate metadata from blockchain
      async function generateMetadataFromBlockchain(id) {
        try {
          // Get metadata from blockchain
          const index = (Number(id) - 1) % 10000; // Convert ID to index (0-based)
          console.log(`Fetching metadata for ID ${id}, index ${index}`);
          
          let metadataUri;
          try {
            metadataUri = await metadataBank.getMetadata(index);
            console.log(`Received metadata URI for ID ${id}:`, metadataUri);
          } catch (err) {
            console.error(`Error calling getMetadata for index ${index}:`, err);
            throw err;
          }

          // Parse metadata
          let metadata;
          if (metadataUri.startsWith('data:application/json;base64,')) {
            const base64Json = metadataUri.replace('data:application/json;base64,', '');
            const jsonString = atob(base64Json);
            metadata = JSON.parse(jsonString);
          } else if (metadataUri.startsWith('{')) {
            metadata = JSON.parse(metadataUri);
          } else {
            throw new Error('Invalid metadata format');
          }

          console.log('Fetched metadata from blockchain:', metadata);
          return metadata;
        } catch (error) {
          console.error('Error fetching from blockchain:', error);
          throw error;
        }
      }

      // Generate single random NFT
      async function generateSingle() {
        const id = Math.floor(Math.random() * 10000) + 1;

        if (!isInitialized || !metadataBank) {
          const initialized = await initBlockchain();
          if (!initialized) {
            alert('Failed to connect to blockchain. Please refresh the page.');
            return;
          }
          isInitialized = true;
        }

        try {
          const metadata = await generateMetadataFromBlockchain(id);
          currentMetadata = [metadata];
          displayMetadata(currentMetadata);
        } catch (error) {
          console.error('Failed to generate NFT:', error);
        }
      }

      // Generate specific legendary ID
      async function generateSpecificId(id) {
        document.getElementById('idInput').value = id;
        await generateById();
      }

      // Generate NFT by specific ID
      async function generateById() {
        const idInput = document.getElementById('idInput');
        const id = parseInt(idInput.value);

        if (!id || id < 1 || id > 10000) {
          alert('Please enter a valid ID between 1 and 10000');
          return;
        }

        if (!isInitialized || !metadataBank) {
          const initialized = await initBlockchain();
          if (!initialized) {
            alert('Failed to connect to blockchain. Please refresh the page.');
            return;
          }
          isInitialized = true;
        }

        try {
          const metadata = await generateMetadataFromBlockchain(id);
          currentMetadata = [metadata];
          displayMetadata(currentMetadata);
        } catch (error) {
          console.error('Failed to generate NFT:', error);
        }
      }

      // Navigate to next ID
      async function generateNext() {
        const idInput = document.getElementById('idInput');
        const currentId = parseInt(idInput.value) || 0;
        let nextId = currentId + 1;
        if (nextId > 10000) nextId = 1;

        idInput.value = nextId;
        await generateById();
      }

      // Navigate to previous ID
      async function generatePrev() {
        const idInput = document.getElementById('idInput');
        const currentId = parseInt(idInput.value) || 1;
        let prevId = currentId - 1;
        if (prevId < 1) prevId = 10000;

        idInput.value = prevId;
        await generateById();
      }

      // Copy text to clipboard
      function copyToClipboard(text, button) {
        navigator.clipboard
          .writeText(text)
          .then(() => {
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            setTimeout(() => {
              button.textContent = originalText;
            }, 2000);
          })
          .catch((err) => {
            console.error('Failed to copy:', err);
          });
      }

      // HTML escape helper
      function escapeHtml(unsafe) {
        return unsafe
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }

      // Display metadata
      function displayMetadata(metadataArray) {
        const display = document.getElementById('metadataDisplay');
        display.innerHTML = '';
        display.className = 'metadata-display show';

        // Since we only display one metadata at a time, use the first one
        const metadata = metadataArray[0];
        if (!metadata) return;

        // Check for special attributes
        const isSpecial = metadata.attributes.find((a) => a.trait_type === 'Special');
        const isLegendary = metadata.attributes.find((a) => a.trait_type === 'Legendary');
        const rarity = metadata.attributes.find((a) => a.trait_type === 'Rarity')?.value || 'Common';

        // Add rarity class
        if (rarity === 'Legendary') display.classList.add('rarity-legendary');
        else if (rarity === 'Epic') display.classList.add('rarity-epic');
        else if (rarity === 'Rare') display.classList.add('rarity-rare');

        // Extract ID from name
        const idMatch = metadata.name.match(/#(\d+)$/);
        const nftId = idMatch ? idMatch[1] : '1';
        const metadataUrl = `${window.location.origin}${window.location.pathname}api.php?id=${nftId}`;

        // Build attributes HTML
        const attributesHtml = metadata.attributes
          .map(
            (attr) => `
                <div class="attribute">
                    <div class="attribute-type">${attr.trait_type}</div>
                    <div class="attribute-value">${attr.value}</div>
                </div>
            `
          )
          .join('');

        // Format JSON
        const jsonString = JSON.stringify(metadata, null, 2);

        // Build badges
        let badgesHtml = '';
        if (isLegendary) {
          badgesHtml += '<span class="special-badge legendary-badge">⚡ LEGENDARY ID</span>';
        }
        if (isSpecial) {
          badgesHtml += '<span class="special-badge">✨ SPECIAL COMBO</span>';
        }

        // Build HTML using DOM methods for safety
        display.innerHTML = ''; // Clear existing content

        // Create image container
        const imgContainer = document.createElement('div');
        imgContainer.className = 'metadata-image-container';

        // Decode SVG if it's base64 encoded
        if (metadata.image && metadata.image.startsWith('data:image/svg+xml;base64,')) {
          try {
            const base64Svg = metadata.image.replace('data:image/svg+xml;base64,', '');
            const svg = atob(base64Svg);
            imgContainer.innerHTML = svg;
            // Apply class to the SVG element
            const svgElement = imgContainer.querySelector('svg');
            if (svgElement) {
              svgElement.classList.add('metadata-image');
            }
          } catch (e) {
            console.error('Failed to decode SVG:', e);
            // Fallback to img tag
            const img = document.createElement('img');
            img.src = metadata.image;
            img.alt = metadata.name;
            img.className = 'metadata-image';
            imgContainer.appendChild(img);
          }
        } else {
          // For non-base64 images, use img tag
          const img = document.createElement('img');
          img.src = metadata.image;
          img.alt = metadata.name;
          img.className = 'metadata-image';
          imgContainer.appendChild(img);
        }

        display.appendChild(imgContainer);

        // Create header div
        const headerDiv = document.createElement('div');
        headerDiv.className = 'metadata-header';
        headerDiv.innerHTML = badgesHtml;
        display.appendChild(headerDiv);

        // Create name div
        const nameDiv = document.createElement('div');
        nameDiv.className = 'metadata-name';
        nameDiv.textContent = metadata.name;
        display.appendChild(nameDiv);

        // Create description div
        const descDiv = document.createElement('div');
        descDiv.className = 'metadata-description';
        descDiv.textContent = `"${metadata.description}"`;
        display.appendChild(descDiv);

        // Create attributes div
        const attrsDiv = document.createElement('div');
        attrsDiv.className = 'attributes';
        attrsDiv.innerHTML = attributesHtml;
        display.appendChild(attrsDiv);

        // Create JSON container
        const jsonContainer = document.createElement('div');
        jsonContainer.className = 'json-container';
        jsonContainer.innerHTML = `
            <div class="json-toggle" onclick="toggleJson(this)">
                <span class="toggle-icon">▶</span> View JSON
                <div>
                    <button class="copy-json-button" onclick="event.stopPropagation(); copyToClipboard(this.getAttribute('data-json'), this)" data-json='${jsonString.replace(
                      /'/g,
                      '&#39;'
                    )}'>Copy</button>
                    <button class="copy-json-button" onclick="event.stopPropagation(); downloadSingle(JSON.parse(this.getAttribute('data-metadata')))" data-metadata='${JSON.stringify(
                      metadata
                    ).replace(/'/g, '&#39;')}'>Download</button>
                </div>
            </div>
            <div class="json-display" style="display: none;">
                <pre>${escapeHtml(jsonString)}</pre>
            </div>
        `;
        display.appendChild(jsonContainer);
      }

      // Toggle JSON display
      function toggleJson(element) {
        const container = element.parentElement;
        const jsonDisplay = container.querySelector('.json-display');

        element.classList.toggle('open');

        if (jsonDisplay.style.display === 'none') {
          jsonDisplay.style.display = 'block';
          element.querySelector('.toggle-icon').textContent = '▼';
        } else {
          jsonDisplay.style.display = 'none';
          element.querySelector('.toggle-icon').textContent = '▶';
        }
      }

      // Download single metadata
      function downloadSingle(metadata) {
        const idMatch = metadata.name.match(/#(\d+)$/);
        const id = idMatch ? idMatch[1] : '1';
        const filename = `essay_${id}.json`;

        const dataStr = JSON.stringify(metadata, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', filename);
        linkElement.click();
      }

      // Download all metadata as JSON
      function downloadAll() {
        if (currentMetadata.length === 0) {
          alert('Please generate some metadata first!');
          return;
        }

        // Extract ID from the first metadata item's name
        const idMatch = currentMetadata[0].name.match(/#(\d+)$/);
        const id = idMatch ? idMatch[1] : '1';

        const dataStr = JSON.stringify(currentMetadata, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
        const exportFileDefaultName = `PixelMonsters-Story#${id}.json`;

        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
      }

      // Load legendary IDs from blockchain
      async function loadLegendaryIds() {
        const legendaryIdsList = document.getElementById('legendaryIdsList');

        if (!legendaryBankContract) {
          legendaryIdsList.innerHTML =
            '<p style="text-align: center; color: #ff6b6b;">LegendaryBank contract not available</p>';
          return;
        }

        try {
          const count = await legendaryBankContract.getLegendaryCount();
          console.log(`Total legendary tokens: ${count.toString()}`);

          let buttonsHtml = '';
          for (let i = 0; i < count; i++) {
            const tokenId = await legendaryBankContract.legendaryIds(i);
            let title = '';

            try {
              title = await legendaryBankContract.getLegendaryTitle(tokenId);
            } catch (error) {
              // Fallback titles if contract doesn't return one
              const fallbackTitles = {
                666: 'The Beast',
                1337: 'The Chosen',
                9999: 'Final Guardian',
                404: 'Lost Soul',
                7777: "Fortune's Avatar",
                13: 'The Cursed',
                1000: 'The Millennial',
                42: 'The Answer',
              };
              title = fallbackTitles[Number(tokenId)] || `ID ${tokenId}`;
            }

            buttonsHtml += `<button class="legendary-id-button" onclick="generateSpecificId(${tokenId})">
              ${tokenId} - ${title}
            </button>`;
          }

          legendaryIdsList.innerHTML =
            buttonsHtml || '<p style="text-align: center; color: #666;">No legendary IDs found</p>';
        } catch (error) {
          console.error('Failed to load legendary IDs:', error);
          legendaryIdsList.innerHTML =
            '<p style="text-align: center; color: #ff6b6b;">Failed to load legendary IDs</p>';
        }
      }

      // Handle URL parameters on load
      window.addEventListener('DOMContentLoaded', async () => {
        // Initialize blockchain connection
        const connected = await initBlockchain();

        if (!connected) {
          document.getElementById('metadataDisplay').innerHTML =
            '<div style="text-align: center; padding: 40px; color: #ff6b6b;">Failed to connect to blockchain. Please refresh the page.</div>';
          return;
        }

        // Load legendary IDs
        await loadLegendaryIds();

        const urlParams = new URLSearchParams(window.location.search);
        const idFromUrl = urlParams.get('id');

        if (idFromUrl) {
          const id = parseInt(idFromUrl);
          if (id >= 1 && id <= 10000) {
            document.getElementById('idInput').value = id;
            await generateById();
          } else {
            await generateSingle();
          }
        } else {
          await generateSingle();
        }
      });
    </script>
  </body>
</html>
