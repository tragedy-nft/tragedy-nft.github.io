<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RPC Cache Test - The Mythical Cursed-Nightmare</title>
    <link rel="stylesheet" href="css/styles.css" />
    <style>
      .test-container {
        max-width: 800px;
        margin: 50px auto;
        padding: 20px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid var(--color-primary);
        border-radius: 10px;
      }

      .test-section {
        margin: 20px 0;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
      }

      .test-section h2 {
        color: #ffffff;
        margin-top: 0;
      }

      .test-button {
        margin: 5px;
        padding: 10px 20px;
        background: var(--color-primary);
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s;
      }

      .test-button:hover {
        background: var(--color-secondary);
        transform: scale(1.05);
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 10px;
        margin: 20px 0;
      }

      .stat-card {
        padding: 15px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 5px;
        text-align: center;
        color: #ffffff;
      }

      .stat-value {
        font-size: 2em;
        font-weight: bold;
        color: var(--color-primary);
      }

      .stat-card div:last-child {
        color: #ccc;
        font-size: 0.9em;
        margin-top: 5px;
      }

      .log-area {
        background: #000;
        color: #0f0;
        padding: 10px;
        border-radius: 5px;
        font-family: monospace;
        font-size: 12px;
        max-height: 300px;
        overflow-y: auto;
        white-space: pre-wrap;
      }

      .cache-controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .toggle-switch {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        color: #ffffff;
      }

      .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 34px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 34px;
      }

      .slider:before {
        position: absolute;
        content: '';
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }

      input:checked + .slider {
        background-color: var(--color-primary);
      }

      input:checked + .slider:before {
        transform: translateX(26px);
      }
    </style>
  </head>
  <body>
    <div class="test-container">
      <h1>🔧 RPC Cache Test Suite</h1>

      <div class="test-section">
        <h2>📊 Cache Statistics</h2>
        <div class="stats" id="stats">
          <div class="stat-card">
            <div class="stat-value" id="hits">0</div>
            <div>Cache Hits</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="misses">0</div>
            <div>Cache Misses</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="hitRate">0%</div>
            <div>Hit Rate</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="cacheSize">0</div>
            <div>Cached Items</div>
          </div>
        </div>
      </div>

      <div class="test-section">
        <h2>🎮 Cache Controls</h2>
        <div class="cache-controls">
          <div class="toggle-switch">
            <label for="cacheToggle">Cache Enabled:</label>
            <label class="switch">
              <input type="checkbox" id="cacheToggle" checked />
              <span class="slider"></span>
            </label>
          </div>
          <button class="test-button" onclick="clearCache()">🗑️ Clear Cache</button>
          <button class="test-button" onclick="clearExpired()">🧹 Clear Expired</button>
          <button class="test-button" onclick="resetStats()">📊 Reset Stats</button>
        </div>
      </div>

      <div class="test-section">
        <h2>🧪 Test Operations</h2>
        <button class="test-button" onclick="connectWallet()">🔗 Connect Wallet</button>
        <button class="test-button" onclick="testImmutableData()">📜 Test Immutable Data</button>
        <button class="test-button" onclick="testDynamicData()">⚡ Test Dynamic Data</button>
        <button class="test-button" onclick="testBatchOperations()">🔄 Test Batch Operations</button>
        <button class="test-button" onclick="testCacheExpiry()">⏰ Test Cache Expiry</button>
        <button class="test-button" onclick="runAllTests()">🚀 Run All Tests</button>
      </div>

      <div class="test-section">
        <h2>📝 Test Log</h2>
        <div class="log-area" id="logArea"></div>
      </div>
    </div>

    <!-- Scripts -->
    <script src="js/utils/console-override.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="js/contracts/cache.js"></script>
    <script src="js/wallet/manager.js"></script>
    <script src="js/contracts/manager.js"></script>

    <script>
      let contractManager;
      let walletManager;
      let bankedNFTContract;
      const logArea = document.getElementById('logArea');

      // Initialize on page load
      window.addEventListener('load', async () => {
        // Initialize ContractManager
        contractManager = new ContractManager();
        await contractManager.init();
        log('ContractManager initialized', 'success');
        
        // Initialize cache if available
        if (window.contractCache) {
          log('Cache system available', 'success');
        }
        
        // Try to initialize contract with default network if addresses are available
        if (window.CONTRACTS_CONFIG) {
          // Find the first available network with a valid contract address
          const availableChains = [21201, 137]; // Prefer Bon-Soleil for testing
          for (const chainId of availableChains) {
            const contractAddress = window.CONTRACTS_CONFIG.getContract(chainId, 'bankedNFT');
            if (contractAddress && contractAddress !== '0x0000000000000000000000000000000000000000') {
              log(`Default network selected: Chain ${chainId}`, 'info');
              break;
            }
          }
        }
        
        // Initialize WalletManager
        walletManager = new WalletManager({
          onConnect: async (account) => {
            log(`Wallet connected: ${account}`, 'success');
            
            try {
              // Get contract from ContractManager when wallet connects
              const chainId = await walletManager.getCurrentChainId();
              log(`Current network: Chain ${chainId}`);
              
              // Check if we have a contract for this chain
              const contractAddress = window.CONTRACTS_CONFIG?.getContract(chainId, 'bankedNFT');
              if (!contractAddress || contractAddress === '0x0000000000000000000000000000000000000000') {
                log(`No contract found for chain ${chainId}. Please switch to Bon-Soleil (21201) in MetaMask.`, 'error');
                return;
              }
              
              // Get contract instance from ContractManager
              bankedNFTContract = contractManager.getContract('bankedNFT', chainId);
              if (!bankedNFTContract) {
                log(`Failed to get contract instance for chain ${chainId}`, 'error');
                return;
              }
              
              log(`Contract initialized on chain ${chainId}`, 'success');
            } catch (error) {
              log(`Failed to initialize contract: ${error.message}`, 'error');
            }
            
            updateStats();
          },
          onDisconnect: () => {
            log('Wallet disconnected', 'info');
            bankedNFTContract = null;
          }
        });
        await walletManager.init();
        
        // Set wallet manager on ContractManager
        contractManager.setWalletManager(walletManager);
        
        log('RPC Cache Test Suite initialized');

        // Setup cache toggle
        document.getElementById('cacheToggle').addEventListener('change', (e) => {
          if (window.contractCache) {
            window.contractCache.enabled = e.target.checked;
            log(`Cache ${e.target.checked ? 'enabled' : 'disabled'}`);
          }
        });
      });

      // Logging function
      function log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const prefix = type === 'error' ? '❌' : type === 'success' ? '✅' : 'ℹ️';
        logArea.textContent += `[${timestamp}] ${prefix} ${message}\n`;
        logArea.scrollTop = logArea.scrollHeight;
      }

      // Update statistics display
      async function updateStats() {
        if (window.contractCache) {
          const stats = window.contractCache.getStats();
          document.getElementById('hits').textContent = stats.hits;
          document.getElementById('misses').textContent = stats.misses;
          const total = stats.hits + stats.misses;
          const hitRate = total > 0 ? Math.round((stats.hits / total) * 100) : 0;
          document.getElementById('hitRate').textContent = hitRate + '%';
          
          // getCacheSize is async
          window.contractCache.getCacheSize().then(size => {
            document.getElementById('cacheSize').textContent = size;
          });
        }
      }

      // Connect wallet
      async function connectWallet() {
        try {
          log('Connecting wallet...');
          await walletManager.connect();
        } catch (error) {
          log(`Failed to connect wallet: ${error.message}`, 'error');
        }
      }

      // Test immutable data caching
      async function testImmutableData() {
        if (!walletManager.isWalletConnected()) {
          log('Please connect wallet first', 'error');
          return;
        }
        
        // Ensure contract is initialized
        if (!bankedNFTContract) {
          log('Contract not initialized. Trying to initialize...', 'info');
          try {
            const chainId = await walletManager.getCurrentChainId();
            bankedNFTContract = contractManager.getContract('bankedNFT', chainId);
            if (!bankedNFTContract) {
              log(`Failed to get contract instance for chain ${chainId}`, 'error');
              return;
            }
            log(`Contract initialized on chain ${chainId}`, 'success');
          } catch (error) {
            log(`Failed to initialize contract: ${error.message}`, 'error');
            return;
          }
        }

        log('Testing immutable data caching...');

        try {
          // Clear stats before test
          if (window.contractCache) {
            window.contractCache.resetStats();
          }
          
          // First call - should miss cache
          log('Making first call to name() (should miss cache)...');
          const start1 = performance.now();
          const name1 = await bankedNFTContract.name();
          const time1 = performance.now() - start1;
          log(`First call result: "${name1}" - ${time1.toFixed(2)}ms`);

          // Second call - should hit cache
          log('Making second call to name() (should hit cache)...');
          const start2 = performance.now();
          const name2 = await bankedNFTContract.name();
          const time2 = performance.now() - start2;
          log(`Second call result: "${name2}" - ${time2.toFixed(2)}ms`, 'success');
          
          // Show performance improvement
          const speedup = (time1 / time2).toFixed(1);
          log(`Cache speedup: ${speedup}x faster`);

          // Test symbol too
          log('Testing symbol() caching...');
          const symbolTime1 = performance.now();
          await bankedNFTContract.symbol();
          const symbolTime2 = performance.now() - symbolTime1;
          
          const symbolTime3 = performance.now();
          await bankedNFTContract.symbol();
          const symbolTime4 = performance.now() - symbolTime3;
          
          log(`Symbol: First call ${symbolTime2.toFixed(2)}ms, Second call ${symbolTime4.toFixed(2)}ms`);

          updateStats();
        } catch (error) {
          log(`Test failed: ${error.message}`, 'error');
        }
      }

      // Test dynamic data caching
      async function testDynamicData() {
        if (!walletManager.isWalletConnected()) {
          log('Please connect wallet first', 'error');
          return;
        }
        
        // Ensure contract is initialized
        if (!bankedNFTContract) {
          log('Contract not initialized. Trying to initialize...', 'info');
          try {
            const chainId = await walletManager.getCurrentChainId();
            bankedNFTContract = contractManager.getContract('bankedNFT', chainId);
            if (!bankedNFTContract) {
              log(`Failed to get contract instance for chain ${chainId}`, 'error');
              return;
            }
            log(`Contract initialized on chain ${chainId}`, 'success');
          } catch (error) {
            log(`Failed to initialize contract: ${error.message}`, 'error');
            return;
          }
        }

        log('Testing dynamic data caching (30s TTL)...');

        try {
          // First call
          const supply1 = await bankedNFTContract.totalSupply();
          log(`Total supply (cache miss): ${supply1.toString()}`);

          // Second call - should hit cache
          const supply2 = await bankedNFTContract.totalSupply();
          log(`Total supply (cache hit): ${supply2.toString()}`, 'success');

          // Test balance too
          const account = walletManager.getAccount();
          if (account) {
            await bankedNFTContract.balanceOf(account);
            await bankedNFTContract.balanceOf(account);
          }

          updateStats();
        } catch (error) {
          log(`Test failed: ${error.message}`, 'error');
        }
      }

      // Test batch operations
      async function testBatchOperations() {
        if (!walletManager.isWalletConnected()) {
          log('Please connect wallet first', 'error');
          return;
        }
        
        // Ensure contract is initialized
        if (!bankedNFTContract) {
          log('Contract not initialized. Trying to initialize...', 'info');
          try {
            const chainId = await walletManager.getCurrentChainId();
            bankedNFTContract = contractManager.getContract('bankedNFT', chainId);
            if (!bankedNFTContract) {
              log(`Failed to get contract instance for chain ${chainId}`, 'error');
              return;
            }
            log(`Contract initialized on chain ${chainId}`, 'success');
          } catch (error) {
            log(`Failed to initialize contract: ${error.message}`, 'error');
            return;
          }
        }

        log('Testing batch operations...');

        try {
          const start = performance.now();

          // Run multiple operations in parallel
          const account = walletManager.getAccount();
          const promises = [
            bankedNFTContract.name(),
            bankedNFTContract.symbol(),
            bankedNFTContract.totalSupply(),
            bankedNFTContract.maxSupply(),
            bankedNFTContract.mintFee(),
            account ? bankedNFTContract.balanceOf(account) : Promise.resolve(ethers.BigNumber.from('0')),
          ];

          const results = await Promise.all(promises);
          const time = performance.now() - start;

          log(`Batch operations completed in ${time.toFixed(2)}ms`, 'success');
          
          // Format results for display
          const formattedResults = [
            results[0], // name
            results[1], // symbol
            results[2].toString(), // totalSupply
            results[3].toString(), // maxSupply
            ethers.utils.formatEther(results[4]), // mintFee in ETH
            results[5].toString(), // balance
          ];
          
          log(`Results: ${JSON.stringify(formattedResults, null, 2)}`);

          updateStats();
        } catch (error) {
          log(`Test failed: ${error.message}`, 'error');
        }
      }

      // Test cache expiry
      async function testCacheExpiry() {
        if (!walletManager.isWalletConnected()) {
          log('Please connect wallet first', 'error');
          return;
        }

        log('Testing cache expiry (this will take 35 seconds)...');

        try {
          // Get dynamic data
          const supply1 = await bankedNFTContract.totalSupply();
          log(`Initial supply: ${supply1.toString()}`);

          // Wait for cache to expire (30s + 5s buffer)
          log('Waiting for cache to expire...');
          await new Promise((resolve) => setTimeout(resolve, 35000));

          // Should miss cache now
          const supply2 = await bankedNFTContract.totalSupply();
          log(`Supply after expiry: ${supply2.toString()} (should be cache miss)`, 'success');

          updateStats();
        } catch (error) {
          log(`Test failed: ${error.message}`, 'error');
        }
      }

      // Clear cache
      async function clearCache() {
        try {
          if (window.contractCache) {
            await window.contractCache.clear();
            log('Cache cleared', 'success');
            updateStats();
          }
        } catch (error) {
          log(`Failed to clear cache: ${error.message}`, 'error');
        }
      }

      // Clear expired entries
      async function clearExpired() {
        try {
          if (window.contractCache) {
            await window.contractCache.clearExpired();
            log('Expired entries cleared', 'success');
            updateStats();
          }
        } catch (error) {
          log(`Failed to clear expired: ${error.message}`, 'error');
        }
      }

      // Reset statistics
      function resetStats() {
        if (window.contractCache) {
          window.contractCache.resetStats();
          log('Statistics reset', 'success');
          updateStats();
        }
      }

      // Run all tests
      async function runAllTests() {
        log('Running all tests...');
        await testImmutableData();
        await new Promise((resolve) => setTimeout(resolve, 1000));
        await testDynamicData();
        await new Promise((resolve) => setTimeout(resolve, 1000));
        await testBatchOperations();
        log('All tests completed!', 'success');
      }
    </script>
  </body>
</html>
