<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Tragedy NFT: The Mythical Cursed-Nightmare</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: #0a0a0a;
        color: #ffffff;
        line-height: 1.6;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      header {
        text-align: center;
        padding: 40px 0;
        border-bottom: 2px solid #222;
        margin-bottom: 40px;
      }

      h1 {
        font-size: 3em;
        background: linear-gradient(135deg, #ff6b6b, #dc143c);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: 10px;
      }

      .subtitle {
        color: #999;
        font-size: 1.2em;
      }

      .deployment-info {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 30px;
      }

      .deployment-info h3 {
        color: #ff6b6b;
        margin-bottom: 15px;
      }

      .deployment-info p {
        margin: 5px 0;
        font-family: monospace;
        font-size: 0.9em;
      }

      .status {
        margin: 20px 0;
        padding: 15px;
        border-radius: 6px;
        font-weight: bold;
        display: none;
      }

      .status.success {
        background: #1a3a1a;
        border: 1px solid #4caf50;
        color: #4caf50;
        display: block;
      }

      .status.error {
        background: #3a1a1a;
        border: 1px solid #f44336;
        color: #f44336;
        display: block;
      }

      .status.info {
        background: #1a2a3a;
        border: 1px solid #2196f3;
        color: #2196f3;
        display: block;
      }

      .tab-container {
        margin-bottom: 30px;
      }

      .tabs {
        display: flex;
        gap: 10px;
        justify-content: center;
        background: #1a1a1a;
        padding: 10px;
        border-radius: 8px;
      }

      .tab {
        background: #333;
        color: #fff;
        border: 1px solid #444;
        padding: 10px 30px;
        border-radius: 6px;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.3s;
      }

      .tab:hover {
        background: #444;
      }

      .tab.active {
        background: #ff6b6b;
        border-color: #ff6b6b;
      }

      .content-section {
        display: none;
      }

      .content-section.active {
        display: block;
      }

      .viewer-controls {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
      }

      .viewer-controls input {
        background: #0a0a0a;
        color: #fff;
        border: 1px solid #444;
        padding: 10px;
        border-radius: 6px;
        font-size: 16px;
        margin-right: 10px;
      }

      button {
        background: #ff6b6b;
        color: #fff;
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s;
      }

      button:hover {
        background: #dc143c;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
      }

      button:active {
        transform: translateY(0);
      }

      button:disabled {
        background: #444;
        cursor: not-allowed;
        transform: none;
      }

      .nft-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .nft-card {
        background: #0a0a0a;
        border: 1px solid #333;
        border-radius: 8px;
        overflow: hidden;
        transition: transform 0.3s;
      }

      .nft-card:hover {
        transform: translateY(-5px);
        border-color: #ff6b6b;
      }

      .nft-image {
        width: 100%;
        height: 280px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .nft-image svg {
        max-width: 240px;
        max-height: 240px;
      }

      .nft-details {
        padding: 20px;
      }

      .nft-details h4 {
        color: #ff6b6b;
        margin-bottom: 10px;
      }

      .trait {
        display: inline-block;
        background: #1a1a1a;
        padding: 4px 12px;
        border-radius: 16px;
        margin: 4px 4px 4px 0;
        font-size: 12px;
        border: 1px solid #333;
      }

      .trait-label {
        color: #888;
      }

      .trait-value {
        color: #fff;
        font-weight: bold;
      }

      .loading-message {
        text-align: center;
        padding: 40px;
        color: #666;
      }

      .admin-section {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
      }

      .admin-section h3 {
        color: #ff6b6b;
        margin-bottom: 15px;
      }

      .function-group {
        background: #0a0a0a;
        border: 1px solid #444;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 15px;
      }

      .function-group h4 {
        color: #ffa500;
        margin-bottom: 10px;
      }

      .input-group {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
        flex-wrap: wrap;
      }

      .input-group label {
        min-width: 150px;
        color: #aaa;
        display: flex;
        align-items: center;
      }

      .input-group input,
      .input-group select {
        flex: 1;
        min-width: 200px;
        background: #0a0a0a;
        color: #fff;
        border: 1px solid #444;
        padding: 8px;
        border-radius: 4px;
      }

      .wallet-connect {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        text-align: center;
      }

      .connect-button {
        background: #ffa500;
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 6px;
        font-size: 18px;
        cursor: pointer;
        font-weight: bold;
      }

      .connect-button:hover {
        background: #ff8c00;
      }

      .tx-result {
        margin-top: 10px;
        padding: 10px;
        background: #0a0a0a;
        border: 1px solid #333;
        border-radius: 4px;
        font-family: monospace;
        font-size: 12px;
        display: none;
      }

      .tx-result.success {
        border-color: #4caf50;
        color: #4caf50;
      }

      .tx-result.error {
        border-color: #f44336;
        color: #f44336;
      }

      footer {
        text-align: center;
        padding: 40px 0;
        border-top: 1px solid #222;
        color: #666;
      }

      .info-panel {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 30px;
        margin-bottom: 30px;
      }

      .info-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .info-item {
        background: #0a0a0a;
        padding: 15px;
        border-radius: 6px;
        border: 1px solid #222;
      }

      .info-item h4 {
        color: #ff6b6b;
        margin-bottom: 8px;
      }

      .info-item p {
        color: #ccc;
        font-size: 0.9em;
      }

      .code-display {
        background: #0a0a0a;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 20px;
        margin-top: 20px;
        font-family: monospace;
        font-size: 12px;
        white-space: pre-wrap;
        word-break: break-all;
        max-height: 300px;
        overflow-y: auto;
      }

      .display-area {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 30px;
        margin-bottom: 30px;
      }

      .svg-container {
        background: #000;
        border: 2px solid #333;
        border-radius: 8px;
        padding: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 400px;
      }

      .svg-container svg {
        max-width: 100%;
        height: auto;
      }

      /* Floating preview styles */
      .floating-preview {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 500px;
        background: #0a0a0a;
        border: 2px solid #ff6b6b;
        border-radius: 8px;
        padding: 20px;
        z-index: 1000;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.8);
        display: none;
      }

      .floating-preview.active {
        display: block;
      }

      .floating-preview-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .floating-preview-title {
        color: #ff6b6b;
        font-weight: bold;
        font-size: 14px;
      }

      .floating-preview-close {
        background: #ff6b6b;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 2px 8px;
        cursor: pointer;
        font-size: 12px;
      }

      .floating-preview-close:hover {
        background: #dc143c;
      }

      .floating-preview-content {
        background: #000;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 450px;
      }

      .floating-preview-content svg {
        width: 100%;
        height: auto;
        max-width: 450px;
        max-height: 450px;
      }

      .floating-preview-info {
        margin-top: 10px;
        font-size: 12px;
        color: #aaa;
      }

      .floating-preview-info p {
        margin: 2px 0;
      }

      .preview-toggle {
        background: #333;
        color: #fff;
        border: 1px solid #444;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
        margin-left: 10px;
      }

      .preview-toggle:hover {
        background: #444;
      }

      .preview-toggle.active {
        background: #ff6b6b;
        border-color: #ff6b6b;
      }

      /* Fixed composer result - matching floating preview */
      #composer-result {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 500px;
        background: #0a0a0a;
        border: 2px solid #ff6b6b;
        border-radius: 8px;
        padding: 20px;
        z-index: 100;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.8);
      }

      #composer-result .admin-section {
        margin: 0;
        padding: 0;
      }

      #composer-result h3 {
        margin-top: 0;
        margin-bottom: 10px;
        color: #ff6b6b;
        font-weight: bold;
        font-size: 14px;
      }

      #composer-result .status {
        text-align: center;
        color: #ff6b6b;
      }

      #composer-result .error {
        text-align: center;
        color: #ff4444;
      }

      #composer-result .svg-display {
        background: #000;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 450px;
      }

      #composer-result svg {
        width: 100%;
        height: auto;
        max-width: 450px;
        max-height: 450px;
      }

      #composer-result .close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        background: transparent;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #888;
        z-index: 10;
        width: 30px;
        height: 30px;
        line-height: 1;
        transition: color 0.3s;
      }

      #composer-result .close-btn:hover {
        color: #ff6b6b;
      }
    </style>
  </head>
  <body>
    <!-- Floating Preview -->
    <div id="floating-preview" class="floating-preview">
      <div class="floating-preview-header">
        <span class="floating-preview-title">NFT Preview</span>
        <button class="floating-preview-close" onclick="closeFloatingPreview()">
          ✕
        </button>
      </div>
      <div class="floating-preview-content" id="floating-preview-svg">
        <p style="color: #666">No preview available</p>
      </div>
      <div class="floating-preview-info" id="floating-preview-info">
        <p><strong>Name:</strong> <span id="floating-preview-name">-</span></p>
        <p>
          <strong>Token ID:</strong> <span id="floating-preview-id">-</span>
        </p>
        <div id="floating-preview-description" style="display: none">
          <p><strong>Description:</strong></p>
          <p
            id="floating-preview-desc-text"
            style="
              font-size: 12px;
              line-height: 1.4;
              color: #ccc;
              margin: 5px 0;
            "
          >
            -
          </p>
        </div>
        <div
          id="floating-preview-attributes"
          style="display: none; margin-top: 10px"
        >
          <p><strong>Attributes:</strong></p>
          <div id="floating-preview-attrs" style="font-size: 12px"></div>
        </div>
      </div>
    </div>

    <div class="container">
      <header>
        <h1>Tragedy: The Mythical Cursed-Nightmare</h1>
        <p class="subtitle">Dynamic NFT System with Synergy Transformations</p>
      </header>

      <div class="tab-container">
        <div class="tabs">
          <button class="tab active" onclick="switchTab('viewer')">
            ️ NFT Viewer
          </button>
          <button class="tab" onclick="switchTab('minting')">Minting</button>
          <button class="tab" onclick="switchTab('metadata')">
            Metadata Explorer
          </button>
          <button class="tab" onclick="switchTab('composer')">
            Composer Explorer
          </button>
          <button class="tab" onclick="switchTab('materials')">
            Material Explorer
          </button>
          <button class="tab" onclick="switchTab('admin')">Admin</button>
        </div>
      </div>

      <!-- NFT Viewer Section -->
      <div id="viewer-section" class="content-section active">
        <div class="deployment-info">
          <h3>Contract Information</h3>
          <p id="network">Network: <span>Not connected</span></p>
          <p id="nft-address">BankedNFT Contract: <span>Not loaded</span></p>
          <p id="metadata-address">MetadataBank: <span>Not loaded</span></p>
          <p id="total-supply">Total Minted: <span>-</span></p>
          <p id="max-supply">Max Supply: <span>-</span></p>
          <p id="remaining-supply">Remaining: <span>-</span></p>
        </div>

        <div class="viewer-controls">
          <h3 style="color: #ff6b6b; margin-bottom: 20px">🔍 View NFTs</h3>
          <div>
            <input
              type="text"
              id="wallet-address"
              placeholder="Enter wallet address (0x...)"
              style="width: 400px"
            />
            <button onclick="loadWalletNFTs()">View Wallet</button>
            <button onclick="loadAllNFTs()">View All</button>
          </div>
          <div style="margin-top: 15px">
            <input
              type="number"
              id="token-id"
              placeholder="Token ID"
              min="1"
              style="width: 150px"
            />
            <button onclick="loadSingleNFT()">View NFT</button>
          </div>
        </div>

        <div id="status-viewer" class="status"></div>

        <div id="nft-container">
          <div class="loading-message">Select an option above to view NFTs</div>
        </div>
      </div>

      <!-- Minting Section -->
      <div id="minting-section" class="content-section">
        <div class="wallet-connect" id="wallet-section-minting">
          <h3>Connect Wallet to Mint NFTs</h3>
          <button class="connect-button" onclick="connectWallet()">
            🦊 Connect MetaMask
          </button>
          <p id="wallet-status-minting" style="margin-top: 10px; color: #888">
            Not connected
          </p>
        </div>

        <div id="minting-controls" style="display: none">
          <div class="admin-section">
            <h3>🎨 Mint Your NFT</h3>

            <div class="info-panel">
              <h4>Minting Information</h4>
              <div class="info-grid">
                <div class="info-item">
                  <h4>Collection Name</h4>
                  <p id="collection-name">Loading...</p>
                </div>
                <div class="info-item">
                  <h4>Symbol</h4>
                  <p id="collection-symbol">Loading...</p>
                </div>
                <div class="info-item">
                  <h4>Total Supply</h4>
                  <p id="mint-total-supply">Loading...</p>
                </div>
                <div class="info-item">
                  <h4>Max Supply</h4>
                  <p id="mint-max-supply">Loading...</p>
                </div>
                <div class="info-item">
                  <h4>Remaining</h4>
                  <p id="mint-remaining">Loading...</p>
                </div>
                <div class="info-item">
                  <h4>Mint Fee</h4>
                  <p id="mint-fee">Loading...</p>
                </div>
                <div class="info-item">
                  <h4>Your Balance</h4>
                  <p id="user-balance">Loading...</p>
                </div>
                <div class="info-item">
                  <h4>Can Mint</h4>
                  <p id="can-mint">Loading...</p>
                </div>
                <div class="info-item">
                  <h4>Royalty Rate</h4>
                  <p id="royalty-rate">Loading...</p>
                </div>
                <div class="info-item">
                  <h4>Owner</h4>
                  <p id="contract-owner">Loading...</p>
                </div>
              </div>
            </div>

            <div class="function-group">
              <h4>Regular Mint</h4>
              <p style="color: #888; margin-bottom: 10px">
                Mint a transferable NFT with random metadata from the bank
              </p>
              <button onclick="mintNFT()">Mint NFT</button>
              <div id="mint-result" class="tx-result"></div>
            </div>

            <div class="function-group">
              <h4>Soul-Bound Mint</h4>
              <p style="color: #888; margin-bottom: 10px">
                Mint a non-transferable NFT bound to your address
              </p>
              <button onclick="mintSoulBoundNFT()">Mint Soul-Bound NFT</button>
              <div id="soulbound-result" class="tx-result"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Metadata Explorer Section -->
      <div id="metadata-section" class="content-section">
        <div class="deployment-info">
          <h3>📊 MetadataBank Information</h3>
          <p id="metadata-bank-address">
            MetadataBank: <span>Not loaded</span>
          </p>
          <p id="metadata-count">Total Metadata Entries: <span>-</span></p>
          <p id="metadata-composer">Composer Address: <span>-</span></p>
        </div>

        <div class="admin-section">
          <h3>🔍 Explore Metadata</h3>

          <div class="function-group">
            <h4>Get Metadata by Index</h4>
            <div class="input-group">
              <label>Index (0-9999):</label>
              <input
                type="number"
                id="metadata-index"
                min="0"
                max="9999"
                value="0"
              />
            </div>
            <button onclick="getMetadataByIndex()">Get Metadata</button>
            <div id="metadata-result" class="tx-result"></div>
          </div>

          <div class="function-group">
            <h4>Decode Token ID</h4>
            <div class="input-group">
              <label>Token ID:</label>
              <input type="number" id="decode-token-id" min="1" value="1" />
            </div>
            <button onclick="decodeTokenId()">Decode Parameters</button>
            <div id="decode-result" class="tx-result"></div>
          </div>

          <div class="function-group">
            <h4>Random Metadata</h4>
            <p style="color: #888; margin-bottom: 10px">
              Get a random metadata entry from the bank
            </p>
            <button onclick="getRandomMetadata()">Get Random Metadata</button>
          </div>
        </div>

        <div id="metadata-display" style="display: none">
          <div class="info-panel">
            <h3>Metadata Details</h3>
            <div
              class="code-display"
              id="raw-metadata"
              style="display: block; max-height: 200px"
            ></div>
          </div>

          <div class="info-panel">
            <h3>🎨 Decoded Content</h3>
            <div class="info-grid">
              <div class="info-item">
                <h4>Name</h4>
                <p id="metadata-name">-</p>
              </div>
              <div class="info-item">
                <h4>Description</h4>
                <p id="metadata-description">-</p>
              </div>
              <div class="info-item">
                <h4>Attributes</h4>
                <div id="metadata-attributes"></div>
              </div>
            </div>
          </div>

          <div class="display-area">
            <h3 style="color: #ff6b6b; margin-bottom: 20px">🖼️ NFT Preview</h3>
            <div class="svg-container" id="metadata-svg-container">
              <p style="color: #666">Loading...</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Material Explorer Section -->
      <div id="materials-section" class="content-section">
        <h2>Material Explorer</h2>
        <div class="deployment-info">
          <h3>Contract Information</h3>
          <p>MonsterBank: <span id="material-monster-bank">Not loaded</span></p>
          <p>ItemBank: <span id="material-item-bank">Not loaded</span></p>
          <p>
            BackgroundBank:
            <span id="material-background-bank">Not loaded</span>
          </p>
          <p>EffectBank: <span id="material-effect-bank">Not loaded</span></p>
        </div>
        <div class="status" id="materials-status">
          <span class="loading">Loading materials...</span>
        </div>
        <div id="materials-container"></div>
      </div>

      <!-- Composer Explorer Section -->
      <div id="composer-section" class="content-section">
        <h2>Composer Explorer</h2>
        <div class="deployment-info">
          <h3>Contract Information</h3>
          <p>Composer: <span id="composer-address-info">Not loaded</span></p>
          <p>MonsterBank: <span id="composer-monster-bank">Not loaded</span></p>
          <p>ItemBank: <span id="composer-item-bank">Not loaded</span></p>
          <p>
            BackgroundBank:
            <span id="composer-background-bank">Not loaded</span>
          </p>
          <p>EffectBank: <span id="composer-effect-bank">Not loaded</span></p>
        </div>
        <div class="admin-section">
          <h3>Test Composition</h3>
          <div class="function-group">
            <label>Species:</label>
            <select id="composer-species" class="input-field">
              <option value="0">0 - Werewolf</option>
              <option value="1">1 - Goblin</option>
              <option value="2">2 - Frankenstein</option>
              <option value="3">3 - Demon</option>
              <option value="4">4 - Dragon</option>
              <option value="5">5 - Zombie</option>
              <option value="6">6 - Vampire</option>
              <option value="7">7 - Mummy</option>
              <option value="8">8 - Succubus</option>
              <option value="9">9 - Skeleton</option>
            </select>
          </div>
          <div class="function-group">
            <label>Background:</label>
            <select id="composer-background" class="input-field">
              <option value="0">0 - Bloodmoon</option>
              <option value="1">1 - Abyss</option>
              <option value="2">2 - Decay</option>
              <option value="3">3 - Corruption</option>
              <option value="4">4 - Venom</option>
              <option value="5">5 - Void</option>
              <option value="6">6 - Inferno</option>
              <option value="7">7 - Frost</option>
              <option value="8">8 - Ragnarok</option>
              <option value="9">9 - Shadow</option>
            </select>
          </div>
          <div class="function-group">
            <label>Item:</label>
            <select id="composer-item" class="input-field">
              <option value="0">0 - Crown</option>
              <option value="1">1 - Sword</option>
              <option value="2">2 - Shield</option>
              <option value="3">3 - Poison</option>
              <option value="4">4 - Torch</option>
              <option value="5">5 - Wine</option>
              <option value="6">6 - Scythe</option>
              <option value="7">7 - Staff</option>
              <option value="8">8 - Shoulder</option>
              <option value="9">9 - Amulet</option>
              <option value="10">10 - Head</option>
              <option value="11">11 - Arm</option>
            </select>
          </div>
          <div class="function-group">
            <label>Effect:</label>
            <select id="composer-effect" class="input-field">
              <option value="0">0 - Seizure</option>
              <option value="1">1 - Mindblast</option>
              <option value="2">2 - Confusion</option>
              <option value="3">3 - Meteor</option>
              <option value="4">4 - Bats</option>
              <option value="5">5 - Poisoning</option>
              <option value="6">6 - Lightning</option>
              <option value="7">7 - Blizzard</option>
              <option value="8">8 - Burning</option>
              <option value="9">9 - Brainwash</option>
              <option value="10">10 - Blackout</option>
              <option value="11">11 - Matrix</option>
            </select>
          </div>
          <button class="btn-action" onclick="testComposer()">
            Compose SVG
          </button>
        </div>
        <div id="composer-result">
          <button
            class="close-btn"
            onclick="document.getElementById('composer-result').style.display='none'"
            title="Close"
          >
            ×
          </button>
          <div class="admin-section">
            <h3>Composition Result</h3>
            <div class="svg-display">
              <p style="color: #666">Click "Compose SVG" to see the result</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Admin Section -->
      <div id="admin-section" class="content-section">
        <div class="wallet-connect" id="wallet-section-admin">
          <h3>Connect Wallet for Admin Functions</h3>
          <button class="connect-button" onclick="connectWallet()">
            🦊 Connect MetaMask
          </button>
          <p id="wallet-status-admin" style="margin-top: 10px; color: #888">
            Not connected
          </p>
        </div>

        <div id="admin-controls" style="display: none">
          <div class="admin-section">
            <h3>👤 Owner Functions</h3>

            <div class="function-group">
              <h4>Update Configuration</h4>
              <div class="input-group">
                <label>Collection Name:</label>
                <input
                  type="text"
                  id="config-name"
                  placeholder="Tragedy Myth Banked"
                />
              </div>
              <div class="input-group">
                <label>Collection Symbol:</label>
                <input type="text" id="config-symbol" placeholder="MYTHB" />
              </div>
              <div class="input-group">
                <label>Mint Fee (ETH):</label>
                <input
                  type="number"
                  id="config-fee"
                  step="0.001"
                  min="0"
                  placeholder="0.01"
                />
              </div>
              <div class="input-group">
                <label>Royalty Rate (%):</label>
                <input
                  type="number"
                  id="config-royalty"
                  min="0"
                  max="100"
                  placeholder="5"
                />
              </div>
              <button onclick="updateConfig()">Update Configuration</button>
              <div id="config-result" class="tx-result"></div>
            </div>

            <div class="function-group">
              <h4>Set MetadataBank</h4>
              <p style="color: #888; font-size: 12px; margin-bottom: 10px">
                Current:
                <span
                  id="current-metadata-bank"
                  style="color: #4caf50; font-family: monospace"
                  >Loading...</span
                >
              </p>
              <div class="input-group">
                <label>Bank Address:</label>
                <input type="text" id="bank-address" placeholder="0x..." />
              </div>
              <button onclick="setMetadataBank()">Set MetadataBank</button>
              <div id="bank-result" class="tx-result"></div>
            </div>

            <div class="function-group">
              <h4>Airdrop NFT</h4>
              <div class="input-group">
                <label>Recipient Address:</label>
                <input type="text" id="airdrop-address" placeholder="0x..." />
              </div>
              <button onclick="airdropNFT()">Airdrop NFT</button>
              <div id="airdrop-result" class="tx-result"></div>
            </div>

            <div class="function-group">
              <h4>Withdraw Funds</h4>
              <p style="color: #888; margin-bottom: 10px">
                Contract Balance: <span id="contract-balance">Loading...</span>
              </p>
              <button onclick="withdrawFunds()">Withdraw All</button>
              <div id="withdraw-result" class="tx-result"></div>
            </div>
          </div>

          <div class="admin-section">
            <h3>Contract Information</h3>
            <div class="function-group">
              <h4>Read Contract States</h4>
              <button onclick="refreshContractInfo()">Refresh Info</button>
              <div
                id="contract-info"
                style="
                  margin-top: 15px;
                  font-family: monospace;
                  font-size: 12px;
                  color: #aaa;
                "
              >
                Click refresh to load contract information...
              </div>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <p>Tragedy NFT System © 2025 - Generative Tragedy Literature</p>
      </footer>
    </div>

    <script>
      // Configuration
      const RPC_URL = "https://dev2.bon-soleil.com/rpc";

      // Contract addresses will be loaded from deployment.json
      let DEPLOYMENT = null;
      let BANKED_NFT_ADDRESS = null;
      let METADATA_BANK_ADDRESS = null;
      let COMPOSER_ADDRESS = null;

      // Helper function to update contract display
      function updateContractDisplay(elementId, address) {
        const element = document.getElementById(elementId);
        if (element && address) {
          element.innerHTML = `<span style="color: #4caf50; font-family: monospace">${address}</span>`;
        }
      }

      // Load deployment data
      async function loadDeployment() {
        try {
          console.log("Loading deployment.json...");
          const response = await fetch("deployment.json");
          console.log("Response status:", response.status);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const text = await response.text();
          console.log("Response text:", text);
          DEPLOYMENT = JSON.parse(text);
          BANKED_NFT_ADDRESS = DEPLOYMENT.contracts.BankedNFT;
          METADATA_BANK_ADDRESS = DEPLOYMENT.contracts.MetadataBank;
          COMPOSER_ADDRESS = DEPLOYMENT.contracts.TragedyComposer;
          console.log("Loaded deployment:", DEPLOYMENT);
          console.log("Metadata address:", METADATA_BANK_ADDRESS);

          // Update Material Explorer contract info
          updateContractDisplay(
            "material-monster-bank",
            DEPLOYMENT.contracts.MonsterBank
          );
          updateContractDisplay(
            "material-item-bank",
            DEPLOYMENT.contracts.ItemBank
          );
          updateContractDisplay(
            "material-background-bank",
            DEPLOYMENT.contracts.BackgroundBank
          );
          updateContractDisplay(
            "material-effect-bank",
            DEPLOYMENT.contracts.EffectBank
          );

          // Update Composer Explorer contract info
          updateContractDisplay(
            "composer-address-info",
            DEPLOYMENT.contracts.TragedyComposer
          );
          updateContractDisplay(
            "composer-monster-bank",
            DEPLOYMENT.contracts.MonsterBank
          );
          updateContractDisplay(
            "composer-item-bank",
            DEPLOYMENT.contracts.ItemBank
          );
          updateContractDisplay(
            "composer-background-bank",
            DEPLOYMENT.contracts.BackgroundBank
          );
          updateContractDisplay(
            "composer-effect-bank",
            DEPLOYMENT.contracts.EffectBank
          );
        } catch (error) {
          console.error("Failed to load deployment.json:", error);
          throw new Error("Failed to load deployment configuration");
        }
      }

      // ABIs
      const BANKED_NFT_ABI = [
        // View functions
        "function name() view returns (string)",
        "function symbol() view returns (string)",
        "function owner() view returns (address)",
        "function maxSupply() view returns (uint256)",
        "function mintFee() view returns (uint256)",
        "function royaltyRate() view returns (uint256)",
        "function totalSupply() view returns (uint256)",
        "function metadataBank() view returns (address)",
        "function tokenURI(uint256 tokenId) view returns (string)",
        "function remainingSupply() view returns (uint256)",
        "function canMint() view returns (bool)",
        "function isSoulBound(uint256 tokenId) view returns (bool)",
        "function balanceOf(address owner) view returns (uint256)",
        "function ownerOf(uint256 tokenId) view returns (address)",
        "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
        "function totalSupply() view returns (uint256)",

        // Write functions
        "function mint() payable returns (uint256)",
        "function mintSoulBound() payable returns (uint256)",
        "function airdrop(address to) returns (uint256)",
        "function burn(uint256 tokenId)",
        "function config(string memory newName, string memory newSymbol, uint256 newMintFee, uint256 newRoyaltyRate)",
        "function setMetadataBank(address bankAddress)",
        "function withdraw()",

        // Events
        "event NFTMinted(address indexed to, uint256 indexed tokenId, address indexed minter, string metadataURI)",
        "event NFTBurned(uint256 indexed tokenId)",
        "event ConfigUpdated(string name, string symbol, uint256 mintFee, uint256 royaltyRate)",
      ];

      const METADATA_BANK_ABI = [
        "function getMetadataCount() view returns (uint256)",
        "function getMetadata(uint256 index) view returns (string)",
        "function composer() view returns (address)",
        "function decodeTokenId(uint256 tokenId) view returns (uint8 species, uint8 background, uint8 item, uint8 effect)",
        "function generateMetadata(uint256 tokenId, uint8 species, uint8 background, uint8 item, uint8 effect) view returns (string)",
      ];

      let provider;
      let bankedNft;
      let metadataBank;
      let finalMetadataBank;
      let signer;
      let currentAccount;
      let materialsLoaded = false;

      async function init() {
        try {
          console.log("Initializing BankedNFT viewer...");
          console.log("ethers loaded:", typeof ethers !== "undefined");
          if (typeof ethers === "undefined") {
            throw new Error(
              "ethers.js library not loaded. Please check your internet connection."
            );
          }

          // Load deployment configuration first
          await loadDeployment();
          if (!DEPLOYMENT) {
            throw new Error("Failed to load deployment configuration");
          }
          console.log("RPC URL:", RPC_URL);
          showStatus("Initializing...", "info", "viewer");

          // Connect to network
          console.log("Connecting to network...");
          try {
            provider = new ethers.providers.JsonRpcProvider(RPC_URL);
            await provider.ready;
            console.log("Connected to network successfully");

            // Update network status immediately
            document.getElementById(
              "network"
            ).innerHTML = `Network: <span style="color: #4caf50">Bon-Soleil Testnet</span>`;
          } catch (networkError) {
            console.error("Network connection error:", networkError);
            document.getElementById(
              "network"
            ).innerHTML = `Network: <span style="color: #ff6b6b">Connection Failed</span>`;
            throw networkError;
          }

          // Initialize contracts
          bankedNft = new ethers.Contract(
            BANKED_NFT_ADDRESS,
            BANKED_NFT_ABI,
            provider
          );
          document.getElementById(
            "nft-address"
          ).innerHTML = `BankedNFT Contract: <span style="color: #4caf50; font-family: monospace">${BANKED_NFT_ADDRESS}</span>`;

          // Get current MetadataBank from BankedNFT
          try {
            METADATA_BANK_ADDRESS = await bankedNft.metadataBank();
            console.log(
              "Current MetadataBank from contract:",
              METADATA_BANK_ADDRESS
            );
            document.getElementById(
              "metadata-address"
            ).innerHTML = `MetadataBank: <span style="color: #4caf50; font-family: monospace">${METADATA_BANK_ADDRESS}</span>`;

            metadataBank = new ethers.Contract(
              METADATA_BANK_ADDRESS,
              METADATA_BANK_ABI,
              provider
            );
            const metadataCount = await metadataBank.getMetadataCount();
            console.log(
              "MetadataBank has",
              metadataCount.toString(),
              "metadata entries"
            );
          } catch (error) {
            console.error("Error getting MetadataBank:", error);
            document.getElementById(
              "metadata-address"
            ).innerHTML = `MetadataBank: <span style="color: #ff6b6b">Error loading</span>`;
          }

          // Initialize final metadata bank for explorer (use current MetadataBank)
          let finalCount = 0;
          let composerAddr;

          if (METADATA_BANK_ADDRESS) {
            finalMetadataBank = metadataBank;
            try {
              finalCount = await finalMetadataBank.getMetadataCount();
              console.log("Metadata count:", finalCount.toString());
            } catch (e) {
              console.error("Error getting metadata count:", e);
            }

            // Use tragedyComposer from deployment
            composerAddr = COMPOSER_ADDRESS;
          }

          // Update Metadata Explorer tab info if elements exist
          const metadataBankElement = document.getElementById(
            "metadata-bank-address"
          );
          if (metadataBankElement) {
            metadataBankElement.innerHTML = `MetadataBank: <span style="color: #4caf50; font-family: monospace">${
              METADATA_BANK_ADDRESS || "Not set"
            }</span>`;
          }

          const metadataCountElement =
            document.getElementById("metadata-count");
          if (metadataCountElement && METADATA_BANK_ADDRESS && finalCount > 0) {
            metadataCountElement.innerHTML = `Total Metadata Entries: <span style="color: #4caf50">${finalCount}</span>`;
          }

          const composerElement = document.getElementById("metadata-composer");
          if (composerElement && COMPOSER_ADDRESS) {
            composerElement.innerHTML = `Composer Address: <span style="color: #4caf50; font-family: monospace">${COMPOSER_ADDRESS}</span>`;
          }

          // Load contract info
          try {
            await loadContractInfo();
          } catch (error) {
            console.error("Error loading contract info:", error);
            // Continue with initialization even if contract info fails
          }

          showStatus("Connected successfully!", "success", "viewer");
        } catch (error) {
          console.error("Initialization error:", error);
          showStatus("Failed to connect: " + error.message, "error", "viewer");

          // Show error state in Contract Information
          document.getElementById(
            "network"
          ).innerHTML = `Network: <span style="color: #ff6b6b">Connection Error</span>`;
          document.getElementById(
            "nft-address"
          ).innerHTML = `BankedNFT Contract: <span style="color: #4caf50; font-family: monospace">${
            BANKED_NFT_ADDRESS || "Not set"
          }</span>`;
          document.getElementById(
            "metadata-address"
          ).innerHTML = `MetadataBank: <span style="color: #ff6b6b">Not loaded</span>`;
          document.getElementById(
            "total-supply"
          ).innerHTML = `Total Minted: <span style="color: #ff6b6b">-</span>`;
          document.getElementById(
            "max-supply"
          ).innerHTML = `Max Supply: <span style="color: #ff6b6b">-</span>`;
          document.getElementById(
            "remaining-supply"
          ).innerHTML = `Remaining: <span style="color: #ff6b6b">-</span>`;
        }
      }

      function showDeploymentInstructions() {
        const container = document.getElementById("nft-container");
        container.innerHTML = `
                <div style="background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 30px; margin: 20px 0;">
                    <h3 style="color: #ff6b6b; margin-bottom: 20px;">🚀 Tragedy NFT System Ready</h3>
                    <p style="margin-bottom: 15px;">The BankedNFT system is deployed and ready to use!</p>
                    <p style="color: #4caf50;">BankedNFT: ${BANKED_NFT_ADDRESS}</p>
                    <p style="color: #4caf50;">Metadata: ${METADATA_BANK_ADDRESS}</p>
                    <p style="color: #4caf50;">Composer: ${COMPOSER_ADDRESS}</p>
                </div>
            `;
      }

      async function loadContractInfo() {
        try {
          // Try to load each value individually to handle partial failures
          let totalMinted = "-";
          let maxSupply = "-";
          let remaining = "-";

          try {
            totalMinted = await bankedNft.totalSupply();
            document.getElementById(
              "total-supply"
            ).innerHTML = `Total Minted: <span style="color: #4caf50">${totalMinted}</span>`;
          } catch (e) {
            console.error("Error loading totalMinted:", e);
          }

          try {
            maxSupply = await bankedNft.maxSupply();
            document.getElementById(
              "max-supply"
            ).innerHTML = `Max Supply: <span style="color: #4caf50">${maxSupply}</span>`;
          } catch (e) {
            console.error("Error loading maxSupply:", e);
          }

          try {
            remaining = await bankedNft.remainingSupply();
            document.getElementById(
              "remaining-supply"
            ).innerHTML = `Remaining: <span style="color: #4caf50">${remaining}</span>`;
          } catch (e) {
            console.error("Error loading remainingSupply:", e);
          }

          // Try to load other info
          try {
            const [name, symbol, owner, mintFee, royaltyRate] =
              await Promise.all([
                bankedNft.name(),
                bankedNft.symbol(),
                bankedNft.owner(),
                bankedNft.mintFee(),
                bankedNft.royaltyRate(),
              ]);

            console.log(`Loaded ${name} (${symbol}) - Owner: ${owner}`);
            console.log(`Mint fee: ${ethers.utils.formatEther(mintFee)} ETH`);
            console.log(`Royalty rate: ${royaltyRate.toNumber() / 100}%`);
          } catch (e) {
            console.error("Error loading additional contract info:", e);
          }
        } catch (error) {
          console.error("Error in loadContractInfo:", error);
          // Show error state in UI
          document.getElementById(
            "total-supply"
          ).innerHTML = `Total Minted: <span style="color: #ff6b6b">Error</span>`;
          document.getElementById(
            "max-supply"
          ).innerHTML = `Max Supply: <span style="color: #ff6b6b">Error</span>`;
          document.getElementById(
            "remaining-supply"
          ).innerHTML = `Remaining: <span style="color: #ff6b6b">Error</span>`;
        }
      }

      function showStatus(message, type, section = "viewer") {
        const statusId =
          section === "viewer" ? "status-viewer" : "status-" + section;
        let status = document.getElementById(statusId);
        if (!status) {
          status = document.getElementById("status-viewer");
        }

        status.textContent = message;
        status.className = "status " + type;

        if (type === "success") {
          setTimeout(() => {
            status.style.display = "none";
          }, 5000);
        }
      }

      function switchTab(tab) {
        // Update tab buttons
        document
          .querySelectorAll(".tab")
          .forEach((t) => t.classList.remove("active"));
        event.target.classList.add("active");

        // Update content sections
        document
          .querySelectorAll(".content-section")
          .forEach((s) => s.classList.remove("active"));
        document.getElementById(tab + "-section").classList.add("active");

        // Load content for specific tabs
        if (tab === "materials" && !materialsLoaded) {
          loadMaterials();
          materialsLoaded = true;
        }
      }

      async function connectWallet() {
        try {
          if (!window.ethereum) {
            alert("Please install MetaMask!");
            return;
          }

          await window.ethereum.request({ method: "eth_requestAccounts" });
          const web3Provider = new ethers.providers.Web3Provider(
            window.ethereum
          );
          signer = web3Provider.getSigner();
          currentAccount = await signer.getAddress();

          // Update contracts with signer
          bankedNft = new ethers.Contract(
            BANKED_NFT_ADDRESS,
            BANKED_NFT_ABI,
            signer
          );
          if (METADATA_BANK_ADDRESS) {
            metadataBank = new ethers.Contract(
              METADATA_BANK_ADDRESS,
              METADATA_BANK_ABI,
              signer
            );
          }

          // Update all wallet status displays
          document.getElementById(
            "wallet-status-minting"
          ).innerHTML = `Connected: ${currentAccount.slice(
            0,
            6
          )}...${currentAccount.slice(-4)}`;
          document.getElementById(
            "wallet-status-admin"
          ).innerHTML = `Connected: ${currentAccount.slice(
            0,
            6
          )}...${currentAccount.slice(-4)}`;

          // Hide connect buttons and show controls
          document.getElementById("wallet-section-minting").style.display =
            "none";
          document.getElementById("wallet-section-admin").style.display =
            "none";
          document.getElementById("minting-controls").style.display = "block";
          document.getElementById("admin-controls").style.display = "block";

          // Load minting info
          await loadMintingInfo();
        } catch (error) {
          console.error("Wallet connection error:", error);
          alert("Failed to connect wallet: " + error.message);
        }
      }

      async function loadMintingInfo() {
        try {
          // Get all contract information
          const [
            name,
            symbol,
            totalSupply,
            maxSupply,
            remainingSupply,
            mintFee,
            canMint,
            royaltyRate,
            owner,
            metadataBank,
          ] = await Promise.all([
            bankedNft.name(),
            bankedNft.symbol(),
            bankedNft.totalSupply(),
            bankedNft.maxSupply(),
            bankedNft.remainingSupply(),
            bankedNft.mintFee(),
            bankedNft.canMint(),
            bankedNft.royaltyRate(),
            bankedNft.owner(),
            bankedNft.metadataBank(),
          ]);

          // Get user balance
          const balance = await provider.getBalance(currentAccount);

          // Update all display elements
          document.getElementById("collection-name").textContent = name;
          document.getElementById("collection-symbol").textContent = symbol;
          document.getElementById("mint-total-supply").textContent =
            totalSupply.toString();
          document.getElementById("mint-max-supply").textContent =
            maxSupply.toString();
          document.getElementById("mint-remaining").textContent =
            remainingSupply.toString();
          document.getElementById("mint-fee").textContent =
            ethers.utils.formatEther(mintFee) + " ETH";
          document.getElementById("user-balance").textContent =
            ethers.utils.formatEther(balance) + " ETH";
          document.getElementById("can-mint").textContent = canMint
            ? "Yes ✅"
            : "No ❌";
          document.getElementById("royalty-rate").textContent =
            royaltyRate.toNumber() / 100 + "%";
          document.getElementById("contract-owner").textContent =
            owner.slice(0, 6) + "..." + owner.slice(-4);

          // Update contract balance for admin
          const contractBalance = await provider.getBalance(BANKED_NFT_ADDRESS);
          document.getElementById("contract-balance").textContent =
            ethers.utils.formatEther(contractBalance) + " ETH";

          // Update current MetadataBank display
          const currentMetadataBankElement = document.getElementById(
            "current-metadata-bank"
          );
          if (currentMetadataBankElement) {
            currentMetadataBankElement.textContent = metadataBank;
          }
        } catch (error) {
          console.error("Error loading minting info:", error);
        }
      }

      async function loadWalletNFTs() {
        const address = document.getElementById("wallet-address").value.trim();
        if (!address || !ethers.utils.isAddress(address)) {
          showStatus("Please enter a valid wallet address", "error");
          return;
        }

        showStatus("Loading wallet NFTs...", "info");
        const container = document.getElementById("nft-container");
        container.innerHTML = '<div class="loading-message">Loading...</div>';

        try {
          const balance = await bankedNft.balanceOf(address);
          if (balance.eq(0)) {
            container.innerHTML =
              '<div class="loading-message">No NFTs found in this wallet</div>';
            return;
          }

          const nfts = [];
          for (let i = 0; i < balance.toNumber(); i++) {
            const tokenId = await bankedNft.tokenOfOwnerByIndex(address, i);
            nfts.push(tokenId);
          }

          await displayNFTs(nfts);
          showStatus(`Found ${nfts.length} NFTs`, "success");
        } catch (error) {
          console.error("Error loading wallet NFTs:", error);
          showStatus("Error loading NFTs: " + error.message, "error");
          container.innerHTML =
            '<div class="loading-message">Error loading NFTs</div>';
        }
      }

      async function loadAllNFTs() {
        showStatus("Loading all NFTs...", "info");
        const container = document.getElementById("nft-container");
        container.innerHTML = '<div class="loading-message">Loading...</div>';

        try {
          const totalSupply = await bankedNft.totalSupply();

          if (totalSupply.eq(0)) {
            container.innerHTML =
              '<div class="loading-message">No NFTs minted yet</div>';
            return;
          }

          const nfts = [];
          for (let i = 1; i <= Math.min(totalSupply.toNumber(), 20); i++) {
            // Limit to 20 for performance
            nfts.push(ethers.BigNumber.from(i));
          }

          await displayNFTs(nfts);
          showStatus(
            `Showing ${nfts.length} of ${totalSupply} NFTs`,
            "success"
          );
        } catch (error) {
          console.error("Error loading all NFTs:", error);
          showStatus("Error loading NFTs: " + error.message, "error");
        }
      }

      async function loadSingleNFT() {
        const tokenId = document.getElementById("token-id").value;
        if (!tokenId || tokenId < 1) {
          showStatus("Please enter a valid token ID", "error");
          return;
        }

        showStatus(`Loading NFT #${tokenId}...`, "info");

        try {
          await displayNFTs([ethers.BigNumber.from(tokenId)]);
          showStatus(`Loaded NFT #${tokenId}`, "success");
        } catch (error) {
          console.error("Error loading NFT:", error);
          showStatus("Error: NFT not found or not minted yet", "error");
        }
      }

      async function displayNFTs(tokenIds) {
        const container = document.getElementById("nft-container");
        container.innerHTML = "";

        const grid = document.createElement("div");
        grid.className = "nft-grid";

        for (const tokenId of tokenIds) {
          try {
            // Get token URI
            const tokenURI = await bankedNft.tokenURI(tokenId);

            // Get owner and soul-bound status
            const [owner, isSoulBound] = await Promise.all([
              bankedNft.ownerOf(tokenId),
              bankedNft.isSoulBound(tokenId),
            ]);

            // Parse metadata
            let metadata;
            let svg = "";

            if (tokenURI.startsWith("data:application/json;base64,")) {
              const base64Json = tokenURI.replace(
                "data:application/json;base64,",
                ""
              );
              const jsonString = atob(base64Json);
              metadata = JSON.parse(jsonString);

              if (
                metadata.image &&
                metadata.image.startsWith("data:image/svg+xml;base64,")
              ) {
                const base64Svg = metadata.image.replace(
                  "data:image/svg+xml;base64,",
                  ""
                );
                svg = atob(base64Svg);
              }
            } else {
              // Simple metadata format
              metadata = {
                name: `NFT #${tokenId}`,
                description: tokenURI,
                attributes: [],
              };
            }

            // Create card
            const card = document.createElement("div");
            card.className = "nft-card";

            const soulBoundBadge = isSoulBound
              ? '<span style="background: #ff6b6b; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 10px;">SOUL-BOUND</span>'
              : "";

            // Store SVG data in a data attribute to avoid escaping issues
            card.setAttribute("data-svg", svg || "");
            card.setAttribute("data-name", metadata.name || "");
            card.setAttribute("data-tokenid", tokenId || "");

            card.innerHTML = `
                        <div class="nft-image">
                            ${
                              svg ||
                              '<div style="color: #666;">No image available</div>'
                            }
                        </div>
                        <div class="nft-details">
                            <h4>${metadata.name}${soulBoundBadge}</h4>
                            <p style="color: #888; font-size: 12px; margin-bottom: 10px;">
                                Owner: ${owner.slice(0, 6)}...${owner.slice(-4)}
                                <button class="preview-toggle" onclick="showPreviewFromCard(this.closest('.nft-card'))">Preview</button>
                            </p>
                            <p style="color: #aaa; font-size: 13px; margin-bottom: 10px;">
                                ${metadata.description || "No description"}
                            </p>
                            ${
                              metadata.attributes.length > 0
                                ? `
                                <div>
                                    ${metadata.attributes
                                      .map(
                                        (attr) => `
                                        <span class="trait">
                                            <span class="trait-label">${attr.trait_type}:</span>
                                            <span class="trait-value">${attr.value}</span>
                                        </span>
                                    `
                                      )
                                      .join("")}
                                </div>
                            `
                                : ""
                            }
                        </div>
                    `;

            grid.appendChild(card);
          } catch (error) {
            console.error(`Error loading NFT ${tokenId}:`, error);
          }
        }

        container.appendChild(grid);
      }

      // Metadata Explorer Functions
      async function getMetadataByIndex() {
        const index = document.getElementById("metadata-index").value;
        const resultDiv = document.getElementById("metadata-result");

        try {
          resultDiv.textContent = "Loading...";
          resultDiv.className = "tx-result";
          resultDiv.style.display = "block";

          const metadata = await finalMetadataBank.getMetadata(index);

          resultDiv.textContent = `Loaded metadata for index ${index}`;
          resultDiv.className = "tx-result success";

          displayMetadata(metadata);
        } catch (error) {
          console.error("Error loading metadata:", error);
          resultDiv.textContent = `Error: ${error.reason || error.message}`;
          resultDiv.className = "tx-result error";
        }
      }

      async function decodeTokenId() {
        const tokenId = document.getElementById("decode-token-id").value;
        const resultDiv = document.getElementById("decode-result");

        try {
          resultDiv.textContent = "Decoding...";
          resultDiv.className = "tx-result";
          resultDiv.style.display = "block";

          const params = await finalMetadataBank.decodeTokenId(tokenId);

          const species = [
            "Werewolf",
            "Goblin",
            "Frankenstein",
            "Demon",
            "Dragon",
            "Zombie",
            "Vampire",
            "Mummy",
            "Succubus",
            "Skeleton",
          ];
          const backgrounds = [
            "Bloodmoon",
            "Abyss",
            "Decay",
            "Corruption",
            "Venom",
            "Void",
            "Inferno",
            "Frost",
            "Ragnarok",
            "Shadow",
          ];
          const items = [
            "Crown",
            "Sword",
            "Shield",
            "Poison",
            "Torch",
            "Wine",
            "Scythe",
            "Staff",
            "Shoulder",
            "Amulet",
          ];
          const effects = [
            "Seizure",
            "Mindblast",
            "Confusion",
            "Meteor",
            "Bats",
            "Poisoning",
            "Lightning",
            "Blizzard",
            "Burning",
            "Brainwash",
          ];

          resultDiv.innerHTML = `
                    Token ID ${tokenId} decodes to:<br>
                    Species: ${species[params.species]} (${params.species})<br>
                    Background: ${backgrounds[params.background]} (${
            params.background
          })<br>
                    Item: ${items[params.item]} (${params.item})<br>
                    Effect: ${effects[params.effect]} (${params.effect})
                `;
          resultDiv.className = "tx-result success";

          // Get and display the metadata for these parameters
          const metadata = await finalMetadataBank.generateMetadata(
            tokenId,
            params.species,
            params.background,
            params.item,
            params.effect
          );
          displayMetadata(metadata);
        } catch (error) {
          console.error("Error decoding token:", error);
          resultDiv.textContent = `Error: ${error.reason || error.message}`;
          resultDiv.className = "tx-result error";
        }
      }

      async function getRandomMetadata() {
        const randomIndex = Math.floor(Math.random() * 10000);
        document.getElementById("metadata-index").value = randomIndex;
        await getMetadataByIndex();
      }

      function displayMetadata(metadataUri) {
        const displayDiv = document.getElementById("metadata-display");
        displayDiv.style.display = "block";

        // Display raw metadata
        document.getElementById("raw-metadata").textContent = metadataUri;

        // Decode and display
        if (metadataUri.startsWith("data:application/json;base64,")) {
          try {
            const base64Json = metadataUri.replace(
              "data:application/json;base64,",
              ""
            );
            const jsonString = atob(base64Json);
            const metadata = JSON.parse(jsonString);

            document.getElementById("metadata-name").textContent =
              metadata.name || "Unknown";
            document.getElementById("metadata-description").textContent =
              metadata.description || "No description";

            // Display attributes
            const attrDiv = document.getElementById("metadata-attributes");
            attrDiv.innerHTML = metadata.attributes
              .map(
                (attr) => `
                        <span class="trait">
                            <span class="trait-label">${attr.trait_type}:</span>
                            <span class="trait-value">${attr.value}</span>
                        </span>
                    `
              )
              .join("");

            // Display SVG
            if (
              metadata.image &&
              metadata.image.startsWith("data:image/svg+xml;base64,")
            ) {
              const base64Svg = metadata.image.replace(
                "data:image/svg+xml;base64,",
                ""
              );
              const svg = atob(base64Svg);
              document.getElementById("metadata-svg-container").innerHTML = svg;

              // Show floating preview with full metadata
              showFloatingPreview(
                svg,
                metadata.name,
                "Metadata Preview",
                metadata
              );
            }
          } catch (error) {
            console.error("Error parsing metadata:", error);
            document.getElementById("metadata-name").textContent =
              "Error parsing metadata";
          }
        }
      }

      // Minting functions
      async function mintNFT() {
        const resultDiv = document.getElementById("mint-result");

        try {
          resultDiv.textContent = "Preparing transaction...";
          resultDiv.className = "tx-result";
          resultDiv.style.display = "block";

          const mintFee = await bankedNft.mintFee();

          resultDiv.textContent = "Sending transaction...";
          const tx = await bankedNft.mint({ value: mintFee });
          resultDiv.textContent = `Transaction sent: ${tx.hash}`;

          const receipt = await tx.wait();

          // Find the minted token ID from events
          let tokenId = "Unknown";
          if (receipt.events) {
            const event = receipt.events.find((e) => e.event === "NFTMinted");
            if (event && event.args && event.args.tokenId) {
              tokenId = event.args.tokenId.toString();
            }
          }

          resultDiv.textContent = `Success! Minted NFT #${tokenId} - TX: ${tx.hash}`;
          resultDiv.className = "tx-result success";

          // Refresh info
          await loadContractInfo();
          await loadMintingInfo();
        } catch (error) {
          console.error("Mint error:", error);
          resultDiv.textContent = `Error: ${error.reason || error.message}`;
          resultDiv.className = "tx-result error";
        }
      }

      async function mintSoulBoundNFT() {
        const resultDiv = document.getElementById("soulbound-result");

        try {
          resultDiv.textContent = "Preparing transaction...";
          resultDiv.className = "tx-result";
          resultDiv.style.display = "block";

          const mintFee = await bankedNft.mintFee();

          resultDiv.textContent = "Sending transaction...";
          const tx = await bankedNft.mintSoulBound({ value: mintFee });
          resultDiv.textContent = `Transaction sent: ${tx.hash}`;

          const receipt = await tx.wait();

          // Find the minted token ID from events
          let tokenId = "Unknown";
          if (receipt.events) {
            const event = receipt.events.find((e) => e.event === "NFTMinted");
            if (event && event.args && event.args.tokenId) {
              tokenId = event.args.tokenId.toString();
            }
          }

          resultDiv.textContent = `Success! Minted Soul-Bound NFT #${tokenId} - TX: ${tx.hash}`;
          resultDiv.className = "tx-result success";

          // Refresh info
          await loadContractInfo();
          await loadMintingInfo();
        } catch (error) {
          console.error("Mint error:", error);
          resultDiv.textContent = `Error: ${error.reason || error.message}`;
          resultDiv.className = "tx-result error";
        }
      }

      // Admin functions
      async function updateConfig() {
        const name = document.getElementById("config-name").value;
        const symbol = document.getElementById("config-symbol").value;
        const fee = document.getElementById("config-fee").value;
        const royalty = document.getElementById("config-royalty").value;
        const resultDiv = document.getElementById("config-result");

        try {
          resultDiv.textContent = "Sending transaction...";
          resultDiv.className = "tx-result";
          resultDiv.style.display = "block";

          const mintFee = ethers.utils.parseEther(fee || "0");
          const royaltyRate = Math.floor((royalty || 0) * 100); // Convert percentage to basis points

          const tx = await bankedNft.config(name, symbol, mintFee, royaltyRate);
          resultDiv.textContent = `Transaction sent: ${tx.hash}`;

          await tx.wait();
          resultDiv.textContent = `Success! Configuration updated - TX: ${tx.hash}`;
          resultDiv.className = "tx-result success";

          // Refresh info
          await loadContractInfo();
        } catch (error) {
          console.error("Config error:", error);
          resultDiv.textContent = `Error: ${error.reason || error.message}`;
          resultDiv.className = "tx-result error";
        }
      }

      async function setMetadataBank() {
        const address = document.getElementById("bank-address").value.trim();
        const resultDiv = document.getElementById("bank-result");

        if (!ethers.utils.isAddress(address)) {
          resultDiv.textContent = "Invalid address";
          resultDiv.className = "tx-result error";
          resultDiv.style.display = "block";
          return;
        }

        try {
          resultDiv.textContent = "Sending transaction...";
          resultDiv.className = "tx-result";
          resultDiv.style.display = "block";

          const tx = await bankedNft.setMetadataBank(address);
          resultDiv.textContent = `Transaction sent: ${tx.hash}`;

          await tx.wait();
          resultDiv.textContent = `Success! MetadataBank updated - TX: ${tx.hash}`;
          resultDiv.className = "tx-result success";

          // Refresh info
          await loadContractInfo();
        } catch (error) {
          console.error("SetBank error:", error);
          resultDiv.textContent = `Error: ${error.reason || error.message}`;
          resultDiv.className = "tx-result error";
        }
      }

      async function airdropNFT() {
        const address = document.getElementById("airdrop-address").value.trim();
        const resultDiv = document.getElementById("airdrop-result");

        if (!ethers.utils.isAddress(address)) {
          resultDiv.textContent = "Invalid address";
          resultDiv.className = "tx-result error";
          resultDiv.style.display = "block";
          return;
        }

        try {
          resultDiv.textContent = "Sending transaction...";
          resultDiv.className = "tx-result";
          resultDiv.style.display = "block";

          const tx = await bankedNft.airdrop(address);
          resultDiv.textContent = `Transaction sent: ${tx.hash}`;

          const receipt = await tx.wait();

          // Find the minted token ID from events
          let tokenId = "Unknown";
          if (receipt.events) {
            const event = receipt.events.find((e) => e.event === "NFTMinted");
            if (event && event.args && event.args.tokenId) {
              tokenId = event.args.tokenId.toString();
            }
          }

          resultDiv.textContent = `Success! Airdropped NFT #${tokenId} to ${address.slice(
            0,
            6
          )}...${address.slice(-4)} - TX: ${tx.hash}`;
          resultDiv.className = "tx-result success";

          // Refresh info
          await loadContractInfo();
        } catch (error) {
          console.error("Airdrop error:", error);
          resultDiv.textContent = `Error: ${error.reason || error.message}`;
          resultDiv.className = "tx-result error";
        }
      }

      async function withdrawFunds() {
        const resultDiv = document.getElementById("withdraw-result");

        try {
          resultDiv.textContent = "Sending transaction...";
          resultDiv.className = "tx-result";
          resultDiv.style.display = "block";

          const tx = await bankedNft.withdraw();
          resultDiv.textContent = `Transaction sent: ${tx.hash}`;

          await tx.wait();
          resultDiv.textContent = `Success! Funds withdrawn - TX: ${tx.hash}`;
          resultDiv.className = "tx-result success";

          // Refresh balance
          await loadMintingInfo();
        } catch (error) {
          console.error("Withdraw error:", error);
          resultDiv.textContent = `Error: ${error.reason || error.message}`;
          resultDiv.className = "tx-result error";
        }
      }

      async function refreshContractInfo() {
        const infoDiv = document.getElementById("contract-info");

        try {
          infoDiv.innerHTML = "Loading...";

          const [
            name,
            symbol,
            owner,
            maxSupply,
            mintFee,
            royaltyRate,
            totalMinted,
            metadataBankAddr,
            canMint,
          ] = await Promise.all([
            bankedNft.name(),
            bankedNft.symbol(),
            bankedNft.owner(),
            bankedNft.maxSupply(),
            bankedNft.mintFee(),
            bankedNft.royaltyRate(),
            bankedNft.totalSupply(),
            bankedNft.metadataBank(),
            bankedNft.canMint(),
          ]);

          const contractBalance = await provider.getBalance(BANKED_NFT_ADDRESS);
          const metadataCount =
            metadataBankAddr !== ethers.constants.AddressZero && metadataBank
              ? await metadataBank.getMetadataCount()
              : 0;

          infoDiv.innerHTML = `
                    <strong>Collection Info:</strong><br>
                    Name: ${name}<br>
                    Symbol: ${symbol}<br>
                    Owner: ${owner}<br>
                    <br>
                    <strong>Supply Info:</strong><br>
                    Total Minted: ${totalMinted}<br>
                    Max Supply: ${maxSupply}<br>
                    Can Mint: ${canMint ? "Yes ✅" : "No ❌"}<br>
                    <br>
                    <strong>Configuration:</strong><br>
                    Mint Fee: ${ethers.utils.formatEther(mintFee)} ETH<br>
                    Royalty Rate: ${royaltyRate.toNumber() / 100}%<br>
                    <br>
                    <strong>Contract State:</strong><br>
                    Contract Balance: ${ethers.utils.formatEther(
                      contractBalance
                    )} ETH<br>
                    MetadataBank: ${metadataBankAddr}<br>
                    Metadata Count: ${metadataCount}<br>
                    <br>
                    <strong>Contract Addresses:</strong><br>
                    BankedNFT: ${BANKED_NFT_ADDRESS}<br>
                    MetadataBank: ${METADATA_BANK_ADDRESS || "Not set"}<br>
                    Final MetadataBank: ${FINAL_METADATA_BANK_ADDRESS}
                `;
        } catch (error) {
          console.error("Info refresh error:", error);
          infoDiv.innerHTML = `Error loading info: ${error.message}`;
        }
      }

      // Floating Preview Functions
      let currentPreviewData = null;

      function showFloatingPreview(svg, name, tokenId, metadata) {
        currentPreviewData = { svg, name, tokenId, metadata };
        const preview = document.getElementById("floating-preview");
        const svgContainer = document.getElementById("floating-preview-svg");
        const nameSpan = document.getElementById("floating-preview-name");
        const idSpan = document.getElementById("floating-preview-id");

        if (svg) {
          // Parse the SVG and update its size attributes for larger display
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(svg, "image/svg+xml");
          const svgElement = svgDoc.querySelector("svg");

          if (svgElement) {
            // Set larger display size while maintaining aspect ratio
            svgElement.setAttribute("width", "450");
            svgElement.setAttribute("height", "450");
            svgContainer.innerHTML = new XMLSerializer().serializeToString(
              svgElement
            );
          } else {
            svgContainer.innerHTML = svg;
          }
        } else {
          svgContainer.innerHTML =
            '<p style="color: #666;">No preview available</p>';
        }

        nameSpan.textContent = name || "Unknown";
        idSpan.textContent = tokenId || "-";

        // Show description and attributes if metadata is provided
        const descDiv = document.getElementById("floating-preview-description");
        const attrsDiv = document.getElementById("floating-preview-attributes");

        if (metadata) {
          // Show description
          if (metadata.description) {
            document.getElementById("floating-preview-desc-text").textContent =
              metadata.description;
            descDiv.style.display = "block";
          } else {
            descDiv.style.display = "none";
          }

          // Show attributes
          if (metadata.attributes && metadata.attributes.length > 0) {
            document.getElementById("floating-preview-attrs").innerHTML =
              metadata.attributes
                .map(
                  (attr) => `
                        <div style="margin: 2px 0;">
                            <span style="color: #888;">${attr.trait_type}:</span>
                            <span style="color: #4caf50;">${attr.value}</span>
                        </div>
                    `
                )
                .join("");
            attrsDiv.style.display = "block";
          } else {
            attrsDiv.style.display = "none";
          }
        } else {
          descDiv.style.display = "none";
          attrsDiv.style.display = "none";
        }

        preview.classList.add("active");
      }

      function closeFloatingPreview() {
        const preview = document.getElementById("floating-preview");
        preview.classList.remove("active");
      }

      function toggleFloatingPreview() {
        const preview = document.getElementById("floating-preview");
        if (preview.classList.contains("active")) {
          closeFloatingPreview();
        } else if (currentPreviewData) {
          showFloatingPreview(
            currentPreviewData.svg,
            currentPreviewData.name,
            currentPreviewData.tokenId
          );
        }
      }

      function showPreviewFromCard(card) {
        const svg = card.getAttribute("data-svg");
        const name = card.getAttribute("data-name");
        const tokenId = card.getAttribute("data-tokenid");
        showFloatingPreview(svg, name, tokenId);
      }

      // Material Explorer Functions
      async function loadMaterials() {
        const container = document.getElementById("materials-container");
        const status = document.getElementById("materials-status");

        try {
          status.innerHTML =
            '<span class="loading">Loading materials...</span>';
          container.innerHTML = "";

          // Material Banks from deployment
          if (!DEPLOYMENT) {
            status.innerHTML =
              '<span class="error">Deployment not loaded</span>';
            return;
          }

          const BANKS = {
            monster: {
              main: DEPLOYMENT.contracts.MonsterBank,
              type: "svg",
            },
            item: {
              main: DEPLOYMENT.contracts.ItemBank,
              type: "svg",
            },
            background: {
              main: DEPLOYMENT.contracts.BackgroundBank,
              type: "url",
            },
            effect: {
              main: DEPLOYMENT.contracts.EffectBank,
              type: "url",
            },
          };

          // Test each bank
          await testMaterialBank(
            "Monsters (SVG stored on-chain)",
            BANKS.monster.main,
            "svg",
            "getMonsterSVG",
            "getMonsterName",
            10,
            container
          );
          await testMaterialBank(
            "Items (SVG stored on-chain)",
            BANKS.item.main,
            "svg",
            "getItemSVG",
            "getItemName",
            12,
            container
          );
          await testMaterialBank(
            "Backgrounds (URL stored, expecting Arweave)",
            BANKS.background.main,
            "url",
            "getBackgroundUrl",
            "getBackgroundName",
            10,
            container
          );
          await testMaterialBank(
            "Effects (URL stored, expecting Arweave)",
            BANKS.effect.main,
            "url",
            "getEffectUrl",
            "getEffectName",
            12,
            container
          );

          status.innerHTML =
            '<span style="color: #4caf50;">Material status check complete</span>';
        } catch (error) {
          status.innerHTML =
            '<span style="color: #ff6b6b;">Error loading materials: ' +
            error.message +
            "</span>";
        }
      }

      async function testMaterialBank(
        title,
        address,
        dataType,
        dataMethod,
        nameMethod,
        count,
        container
      ) {
        const section = document.createElement("div");
        section.className = "admin-section";
        section.innerHTML = `<h3>${title}</h3><div class="info-text" style="margin-bottom: 10px;">Contract: ${address}</div><div class="material-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px;"></div>`;

        const grid = section.querySelector(".material-grid");

        // Create contract with appropriate methods
        const abi = [`function ${nameMethod}(uint8 id) view returns (string)`];

        if (dataType === "svg") {
          abi.push(`function ${dataMethod}(uint8 id) view returns (string)`);
          // Also check if getBackgroundSVG/getEffectSVG exists
          if (
            dataMethod === "getBackgroundUrl" ||
            dataMethod === "getEffectUrl"
          ) {
            const svgMethod = dataMethod.replace("Url", "SVG");
            abi.push(`function ${svgMethod}(uint8 id) view returns (string)`);
          }
        } else {
          abi.push(`function ${dataMethod}(uint8 id) view returns (string)`);
        }

        const contract = new ethers.Contract(address, abi, provider);

        for (let i = 0; i < count; i++) {
          const item = document.createElement("div");
          item.style.cssText =
            "background: #2a2a2a; padding: 10px; border-radius: 5px; text-align: center;";

          try {
            const name = await contract[nameMethod](i);

            if (dataType === "svg") {
              const svg = await contract[dataMethod](i);
              // Force SVG to be 96x96px
              const svgFixed = svg.replace(
                /<svg/,
                '<svg width="96px" height="96px"'
              );
              item.innerHTML = `
                            <div style="background: #555555; padding: 5px; border-radius: 5px; margin-bottom: 5px; min-height: 48px; display: flex; align-items: center; justify-content: center;">${svgFixed}</div>
                            <div style="font-size: 12px; font-weight: bold;">${name}</div>
                            <div style="font-size: 10px; color: #888;">ID: ${i}</div>
                            <div style="font-size: 10px; color: #4caf50;">✓ SVG Data</div>
                        `;
            } else {
              // It's a URL type, try to get URL
              let hasUrl = false;
              let hasSvg = false;
              let url = "";

              try {
                url = await contract[dataMethod](i);
                hasUrl = true;
              } catch (e) {
                // URL method failed
              }

              // Check if SVG method exists
              const svgMethod = dataMethod.replace("Url", "SVG");
              try {
                const svg = await contract[svgMethod](i);
                hasSvg = true;
                // Force SVG to be 96x96px
                const svgFixed = svg.replace(
                  /<svg/,
                  '<svg width="96px" height="96px"'
                );
                item.innerHTML = `
                                <div style="background: white; padding: 5px; border-radius: 5px; margin-bottom: 5px; min-height: 48px; display: flex; align-items: center; justify-content: center;">${svgFixed}</div>
                                <div style="font-size: 12px; font-weight: bold;">${name}</div>
                                <div style="font-size: 10px; color: #888;">ID: ${i}</div>
                                <div style="font-size: 10px; color: #4caf50;">✓ Has SVG method</div>
                            `;
              } catch (e) {
                // SVG method doesn't exist
                if (hasUrl) {
                  // Check if URL is an SVG by trying to fetch it
                  let svgContent = null;
                  let isValidSvg = false;

                  try {
                    // Check if it's a data URL
                    if (url.startsWith("data:")) {
                      const [header, data] = url.split(",");
                      if (header.includes("image/svg+xml")) {
                        // It's an SVG data URL
                        if (header.includes("base64")) {
                          svgContent = atob(data);
                        } else {
                          svgContent = decodeURIComponent(data);
                        }
                        isValidSvg = true;
                      }
                    } else if (url.startsWith("http")) {
                      // For HTTP URLs, we can't fetch directly from browser due to CORS
                      // But we can check if it looks like an SVG URL
                      if (url.includes(".svg") || url.includes("image/svg")) {
                        isValidSvg = true;
                      }
                    }
                  } catch (e) {
                    console.error("Error checking URL content:", e);
                  }

                  if (isValidSvg && svgContent) {
                    // Force SVG to be 96x96px
                    const svgFixed = svgContent.replace(
                      /<svg/,
                      '<svg width="96px" height="96px"'
                    );
                    item.innerHTML = `
                                        <div style="background: white; padding: 5px; border-radius: 5px; margin-bottom: 5px; min-height: 48px; display: flex; align-items: center; justify-content: center;">${svgFixed}</div>
                                        <div style="font-size: 12px; font-weight: bold;">${name}</div>
                                        <div style="font-size: 10px; color: #888;">ID: ${i}</div>
                                        <div style="font-size: 10px; color: #4caf50;">✓ SVG from URL</div>
                                        <a href="${url}" target="_blank" style="font-size: 9px; color: #66b3ff; text-decoration: none;">View on Arweave →</a>
                                    `;
                  } else {
                    item.innerHTML = `
                                        <div style="background: #333; padding: 5px; border-radius: 5px; margin-bottom: 5px; min-height: 48px; display: flex; align-items: center; justify-content: center;">
                                            <span style="color: #ff6b6b; font-size: 24px;"><img src="${url}" width="96px" height="96px"></span>
                                        </div>
                                        <div style="font-size: 12px; font-weight: bold;">${name}</div>
                                        <div style="font-size: 10px; color: #888;">ID: ${i}</div>
                                        <div style="font-size: 10px; color: #ffaa00;">⚠ URL only</div>
                                        <a href="${url}" target="_blank" style="font-size: 9px; color: #66b3ff; word-break: break-all; text-decoration: none; display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${url}</a>
                                        ${
                                          isValidSvg
                                            ? '<div style="font-size: 9px; color: #999;">SVG URL (CORS blocked)</div>'
                                            : ""
                                        }
                                    `;
                  }
                } else {
                  throw new Error("No data method found");
                }
              }
            }

            grid.appendChild(item);
          } catch (error) {
            item.style.cssText =
              "background: #330000; padding: 10px; border-radius: 5px; text-align: center;";
            item.innerHTML = `
                        <div style="color: #ff6b6b; font-size: 12px;">Error ID: ${i}</div>
                        <div style="font-size: 10px; color: #ff9999;">${error.message.substring(
                          0,
                          50
                        )}</div>
                    `;
            grid.appendChild(item);
          }
        }

        container.appendChild(section);
      }

      // Composer Explorer Functions
      async function testComposer() {
        const species = document.getElementById("composer-species").value;
        const background = document.getElementById("composer-background").value;
        const item = document.getElementById("composer-item").value;
        const effect = document.getElementById("composer-effect").value;

        const resultDiv = document.getElementById("composer-result");
        resultDiv.style.display = "block";
        resultDiv.innerHTML = `
          <button class="close-btn" onclick="document.getElementById('composer-result').style.display='none'" title="Close">×</button>
          <div class="status">Composing...</div>`;

        try {
          // Use the fixed composer
          if (!DEPLOYMENT) {
            resultDiv.innerHTML = `
              <button class="close-btn" onclick="document.getElementById('composer-result').style.display='none'" title="Close">×</button>
              <div class="error">Deployment not loaded</div>`;
            return;
          }
          const composerAddress = DEPLOYMENT.contracts.TragedyComposer;
          const composerAbi = [
            "function composeSVG(uint8 species, uint8 background, uint8 item, uint8 effect) view returns (string)",
          ];
          const composer = new ethers.Contract(
            composerAddress,
            composerAbi,
            provider
          );

          const svg = await composer.composeSVG(
            species,
            background,
            item,
            effect
          );

          // Make sure the result div is visible
          resultDiv.style.display = "block";

          resultDiv.innerHTML = `
                    <button class="close-btn" onclick="document.getElementById('composer-result').style.display='none'" title="Close">×</button>
                    <div class="admin-section">
                        <h3>Composition Result</h3>
                        <div class="svg-display">
                            ${svg}
                        </div>
                        <div style="margin-top: 10px; font-size: 12px; color: #aaa;">
                            <p>SVG Length: ${svg.length} characters</p>
                        </div>
                    </div>
                `;
        } catch (error) {
          resultDiv.style.display = "block";
          resultDiv.innerHTML = `
            <button class="close-btn" onclick="document.getElementById('composer-result').style.display='none'" title="Close">×</button>
            <div class="error-message">Error: ${error.message}</div>`;
        }
      }

      // Initialize on load
      window.addEventListener("load", () => {
        // Wait a bit for ethers to fully load
        setTimeout(() => {
          if (typeof ethers !== "undefined") {
            init();
          } else {
            console.error("ethers.js failed to load");
            document.getElementById(
              "network"
            ).innerHTML = `Network: <span style="color: #ff6b6b">Library Load Error</span>`;
            document.getElementById(
              "nft-address"
            ).innerHTML = `BankedNFT Contract: <span style="color: #ff6b6b">Cannot Initialize</span>`;
            document.getElementById(
              "metadata-address"
            ).innerHTML = `MetadataBank: <span style="color: #ff6b6b">Cannot Initialize</span>`;
            showStatus(
              "Failed to load ethers.js library. Check internet connection.",
              "error",
              "viewer"
            );
          }
        }, 100);
      });
    </script>
  </body>
</html>
