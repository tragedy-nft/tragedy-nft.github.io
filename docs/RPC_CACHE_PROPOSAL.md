# RPC キャッシュ戦略プロポーザル

## エグゼクティブサマリー

The Mythical Cursed-Nightmare NFTプロジェクトにおいて、サーバーサイドを使用せずにRPCノードへのリクエストを最適化するためのクライアントサイドキャッシュ戦略を提案します。

### 主要な提案
- **IndexedDB**を使用した大容量・構造化データのキャッシュ
- **TTL（Time To Live）**ベースの自動キャッシュ管理
- **データ特性に応じた3段階のキャッシュ戦略**

## 現状の課題

### 1. RPCノードへの過度な負荷
- 同一データへの繰り返しリクエスト
- ページリロード時の全データ再取得
- 複数ユーザーからの同時アクセス

### 2. ユーザー体験の低下
- レスポンス待機時間
- ネットワーク遅延の影響
- RPCレート制限への抵触リスク

### 3. コスト増加
- RPCプロバイダーの従量課金
- 帯域幅の無駄遣い

## 提案するソリューション

### アーキテクチャ概要

```
┌─────────────┐     ┌──────────────┐     ┌─────────────┐
│   Frontend  │────▶│ Cache Layer  │────▶│  RPC Node   │
│  (Browser)  │◀────│  (IndexedDB) │◀────│  (Ethereum) │
└─────────────┘     └──────────────┘     └─────────────┘
```

### キャッシュ戦略の分類

#### 1. 永続キャッシュ（Immutable Data）
**対象データ**
- コントラクト名 (`name`)
- シンボル (`symbol`)
- 最大供給量 (`maxSupply`)
- トークンURI (`tokenURI`)

**特徴**
- TTL: 無期限
- 一度取得したら変更されない
- ストレージ容量が許す限り保持

#### 2. 長期キャッシュ（Slow-changing Data）
**対象データ**
- ミント価格 (`mintFee`)
- コントラクト設定値

**特徴**
- TTL: 1時間（3,600,000ms）
- 変更頻度が低い
- 定期的な更新で十分

#### 3. 短期キャッシュ（Dynamic Data）
**対象データ**
- 総供給量 (`totalSupply`)
- 残高 (`balanceOf`)
- ETH残高 (`getBalance`)

**特徴**
- TTL: 30秒（30,000ms）
- 頻繁に変更される
- リアルタイム性が重要

## 技術仕様

### IndexedDB スキーマ

```javascript
{
  dbName: 'mythOfTragedy_rpc_cache',
  version: 1,
  objectStore: 'cache',
  schema: {
    key: string,        // "chainId:method:params"
    value: any,         // RPCレスポンスデータ
    timestamp: number,  // キャッシュ作成時刻
    expiry: number      // 有効期限（null = 永続）
  }
}
```

### キャッシュキー生成ルール

```
{chainId}:{method}:{serialized_params}

例:
- "21201:name:{}"
- "21201:balanceOf:{\"address\":\"0x123...\"}"
- "21201:tokenURI:{\"tokenId\":\"1\"}"
```

## 実装計画

### フェーズ1: 基本実装（1週間）
1. `RPCCache`クラスの実装
2. IndexedDBの初期化とエラーハンドリング
3. 基本的なget/set/delete操作

### フェーズ2: 統合（1週間）
1. `Web3Integration`クラスへの組み込み
2. 既存メソッドのキャッシュ対応
3. キャッシュヒット率の計測

### フェーズ3: 最適化（1週間）
1. キャッシュサイズ管理
2. LRU（Least Recently Used）アルゴリズムの実装
3. キャッシュ統計とデバッグツール

## 期待される効果

### パフォーマンス改善
- **RPCリクエスト削減**: 70-80%
- **ページロード時間**: 50%短縮
- **レスポンス時間**: 即時（キャッシュヒット時）

### コスト削減
- **RPCコスト**: 月額60-70%削減見込み
- **帯域幅**: 大幅削減

### ユーザー体験向上
- スムーズなページ遷移
- オフライン時の部分的動作
- 安定したパフォーマンス

## リスクと対策

### 1. キャッシュの不整合
**リスク**: 古いデータの表示
**対策**: 
- 適切なTTL設定
- 重要な操作後の強制リフレッシュ
- バージョン管理

### 2. ストレージ容量
**リスク**: IndexedDBの容量制限
**対策**:
- 古いエントリの自動削除
- キャッシュサイズ監視
- 重要度に応じた削除優先度

### 3. ブラウザ互換性
**リスク**: 古いブラウザでの動作
**対策**:
- フォールバック機能
- 機能検出による分岐
- グレースフルデグラデーション

## 代替案の検討

### 1. LocalStorage
- ❌ 容量制限（5-10MB）
- ❌ 同期的API
- ❌ 文字列のみ

### 2. SessionStorage
- ❌ セッション限定
- ❌ タブ間共有不可

### 3. Cache API + Service Worker
- ✅ 高度な制御
- ❌ 実装複雑度が高い
- ❌ HTTPS必須

## 結論

IndexedDBベースのキャッシュレイヤーは、The Mythical Cursed-Nightmare NFTプロジェクトにとって最適なソリューションです。実装の容易さ、パフォーマンス向上、コスト削減のバランスが取れており、完全にクライアントサイドで動作するWeb3アプリケーションの要件を満たします。

## 次のステップ

1. このプロポーザルの承認
2. プロトタイプの実装とテスト
3. 段階的な本番環境への展開
4. モニタリングと最適化

---

*作成日: 2025年8月8日*
*作成者: Claude Code*